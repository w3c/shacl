<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
  	<head>
    	<title>SHACL Advanced Features 1.1</title>
		<meta charset="utf-8">
    	<script src='https://www.w3.org/Tools/respec/respec-w3c-common' async="async" class='remove'></script>
    	<script class='remove'>
	
			var prepareSyntaxRules = function() {
				$("[data-syntax-rule]").each(function(index, element) {
					var ruleId = $(element).attr("data-syntax-rule");
					var tr = $("<tr class=\"syntax-rule-tr\"><td class=\#syntax-rule-id\"><a class=\"syntax-rule-id-a\" href=\"#syntax-rule-" + ruleId + "\">" + ruleId + "</a></td><td>" + $(element).html() + "</td></tr>");
					tr.find("dfn").replaceWith(function(el) { return $("<a>" + $(this).text() + "</a>"); });
					$("#syntax-rules-table").append(tr);
					$(element).attr("id", "syntax-rule-" + ruleId);
				});
			};
		
			var respecConfig = {
			
				localBiblio: {
					"shacl-js": {
						title: "SHACL JavaScript Extensions",
						authors: [ "Holger Knublauch", "Pano Maria" ],
						href: "https://www.w3.org/TR/shacl-js/",
						status: "WG-NOTE",
						publisher: "W3C"
					}
				},
			
				specStatus: "CG-DRAFT",
				preProcess : [ prepareSyntaxRules ],
				edDraftURI: "https://w3c.github.io/shacl/shacl-af/",
				shortName:  "shacl-af-11",
				editors: [
					{
						name:       "Holger Knublauch",
						url:        "http://knublauch.com/",
						company:    "TopQuadrant, Inc.",
						companyURL: "http://topquadrant.com/",
						w3cid:      46500
					},
					{
						name:       "Dean Allemang",
						url:        "http://workingontologist.com",
						company:    "Working Ontologist LLC.",
						companyURL: "http://workingontologist.com"
					},
					{   
						name:       "Simon Steyskal",
			         	url:        "http://steyskal.info/",
			         	company:    "WU Vienna/Siemens AG",
			         	w3cid: 	73545 
					}
				],
				wg: "SHACL Community Group",
				wgURI: "https://www.w3.org/community/shacl/",
				wgPublicList: "public-shacl",
				wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/73865/status",
				noHighlightCSS: true
			};
	    </script>
 		<style>

			pre {
				tab-size: 3;
				-moz-tab-size: 3; /* Code for Firefox */
				-o-tab-size: 3; /* Code for Opera */
				word-wrap: normal;
			}

			th {
				text-align: left;
			}
			table.rule { background-color: #EBEBE0; }
			table.rule td { text-align: center; }
			td.up { border-bottom:1px solid black; }
			
			td {
				vertical-align: top;
			}
			
			.algorithm {
				background: #fafafc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
				padding: 8px;
			}
			
			.arg {
				font-weight: bold;
				color: #000080;
			}

			.def {
				background: #fcfcfc;
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #c0c0c0;
				margin-bottom: 16px;
			}
			
			.def-sparql {
			}
			
			.def-sparql-body {
				margin-top: 0px;
				margin-bottom: 0px;
			}
			
			.def-text {
			}
			
			.def-text-body {
			}
			
			.def-header {
				color: #a0a0a0;
				font-size: 16px;
				padding-bottom: 8px;
			}
			
			.diagram-class {
				border: 1px solid black; 
				border-radius: 4px; 
				width: 360px;
			}
			
			.diagram-class-name {
				font-size: 16px; 
				font-weight: bold; 
				text-align: center;
			}
			
			.diagram-class-properties {
				border-top: 1px solid black; 
			}
			
			.diagram-class-properties-start {
				padding: 8px;
			}
			
			.diagram-class-properties-section {
				border-top: 1px dashed #808080;
				padding: 8px;
			}
			
			.focus-node-selected {
				color: blue;
			}
			.focus-node-error {
				color: red;
			}

			.triple-can-be-skipped {
				color: grey;
			}
			.focus-node-error {
				color: red;
			}

			.target-can-be-skipped {
				color: darkslategray;
				font-style: italic;
			}
			
			.component-class {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameter-context {
				font-weight: bold;
				font-size: 16px;
			}
			
			.parameters {
				font-weight: bold;
				font-size: 16px;
			}

			.part-header {
				font-weight: bold;
			}
			
			.syntax {
				border-left-style: solid;
				border-left-width: .5em;
				border-color: #d0d0d0;
				margin-bottom: 16px;
				padding: .5em 1em;
				background-color: #f6f6f6;
			}
			
			.syntax-rule-id {
				padding-right: 10px;
			}
			
			.syntax-rule-id-a {
				white-space: nowrap;
			}
			
			.validator-id-a {
				font-weight: bold;
				white-space: nowrap;
			}
		
			.term {
				font-style: italic;
			}
			
			.term-def-header {
				font-style: italic;
				font-weight: bold;
			}
		
			.term-table {
				border-collapse: collapse;
				border-color: #000000;
				margin: 16px;
			}

			.term-table td, th {
				border-width: 1px;
				border-style: solid;
				padding: 5px;
			}
		
			.todo {
				color: red;
			}

			/* example pre taken / adapted from R2RML */
			pre.example-shapes, pre.example-data, pre.example-results, pre.example-other, pre.example-sparql { margin-left: 0; padding: 0 2em; margin-top: 1.5em; padding: 1em; white-space: pre !important; }
			pre.example-shapes:before, pre.example-data:before, pre.example-results:before, pre.example-other:before, pre.example-sparql:before { background: white; display: block; font-family: sans-serif; margin: -1em 0 0.4em -1em; padding: 0.2em 1em; }
			pre.example-shapes { background: #deb; }
			pre.example-shapes, pre.example-shapes:before { border: 1px solid #bbb; }
			pre.example-shapes:before { color: #888; content: "Example shapes graph"; width: 13em; }
			pre.example-data { background: #eeb; }
			pre.example-data, pre.example-data:before { border: 1px solid #cc9; }
			pre.example-data:before { color: #996; content: "Example data graph"; width: 13em; }
			pre.example-results:before { color: #797; content: "Example validation results"; width: 13em; }
			pre.example-other { background: #bed; }
			pre.example-other, pre.example-other:before { border: 1px solid #ddd; }
			pre.example-other:before { color: #888; content: "Example"; width: 13em; }
			pre.example-sparql { background: #bed; }
			pre.example-sparql, pre.example-sparql:before { border: 1px solid #ddd; }
			pre.example-sparql:before { color: #888; content: "Example SPARQL"; width: 13em; }
			.example-results { background: #edb; }
			.example-results, .example-results:before, .example-results th, .example-results td { border: 1px solid #cca; }

			/* our syntax menu for switching */
			div.syntaxmenu {
				border: 1px dotted black;
				padding:0.5em;
				margin: 1em; 
			}

			@media print {
				div.syntaxmenu { display:none; }
			}
		</style>
	</head>
	<body>

		<section id='abstract'>
			This document describes advanced features of the Shapes Constraint Language (SHACL) [[!shacl]]
			including features to define custom targets, annotation properties, user-defined functions,
			node expressions and rules.
			While many of these features rely on SPARQL, they also define extension points
			that can be used by other implementation languages.
		</section>

		<section id='sotd'>
			<p>
				This is the draft has been submitted to the W3C SHACL Community Group for publication as a Community Report as input for a
				potential revision of the SHACL Advanced Features document.
			</p>
			<p>
				<b>Changes since the SHACL-AF Working Group Note release of 08 June 2017</b>
			</p>
			<ul>
				<li>Added <a>Property value rules</a> (as syntactic sugar for certain triple rules)</li>
				<li>Node expressions now work on lists of RDF nodes instead of sets of RDF nodes, allowing duplicates.
					While the potential presence of duplicates is a change in semantics, the previous use cases of
					node expressions (in rules) are unaffected because no duplicate triples can be inferred in an RDF graph.</li>
				<li>sh:nodes is no longer mandatory for sh:filterShape expressions (defaults to sh:this, consistent with sh:path)</li>
				<li>Added <a>exists expression</a></li>
				<li>Added <a>if expression</a></li>
				<li>Added <a>distinct expression</a></li>
				<li>Added <a>count expression</a>, <a>min expression</a>, <a>max expression</a>, <a>sum expression</a> and <a>group concat expression</a></li>
				<li>Added <a>orderBy expression</a>, <a>limit expression</a> and <a>offset expression</a></li>
				<li>Added <a>minus expression</a></li>
				<li>Added <a>SPARQL ASK expression</a> and <a>SPARQL SELECT expression</a></li>
				<li>Fixed an example of sh:path expressions</li>
                <li>Fixed the example of sh:SPARQLTargetType</li>
			</ul>
		</section>
				
		<section class="introductory">
			<h2>Document Conventions</h2>
			<p>
				Some examples in this document use Turtle [[!turtle]].
				The reader is expected to be familiar with SHACL [[!shacl]] and SPARQL [[!sparql11-query]].
			</p>
			<p>
				Within this document, the following namespace prefix bindings are used:
			</p>
			<table class="term-table">
				<tr>
					<th>Prefix</th>
					<th>Namespace</th>
				</tr>
				<tr>
					<td><code>rdf:</code></td>
					<td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
				</tr>
				<tr>
					<td><code>rdfs:</code></td>
					<td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
				</tr>
				<tr>
					<td><code>sh:</code></td>
					<td><code>http://www.w3.org/ns/shacl#</code></td>
				</tr>
				<tr>
					<td><code>xsd:</code></td>
					<td><code>http://www.w3.org/2001/XMLSchema#</code></td>
				</tr>
				<tr>
					<td><code>ex:</code></td>
					<td><code>http://example.com/ns#</code></td>
				</tr>
			</table>
			<p>
				Throughout the document, color-coded boxes containing RDF graphs in Turtle will appear.
				These fragments of Turtle documents use the prefix bindings given above.
			</p>
			<pre class="example-shapes">
# This box represents a shapes graph
&lt;s&gt; &lt;p&gt; &lt;o&gt; .</pre>

			<pre class="example-js">
// This box contains JavaScript code</pre>

			<pre class="example-data">
# This box represents a data graph.</pre>

			<pre class="example-results">
# This box represents an output results graph</pre>

			<p>
				Formal definitions appear in blue boxes:
			</p>
			<div class="def def-sparql">
				<div class="def-header">TEXTUAL DEFINITIONS</div>
<pre class="def-sparql-body">
# This box contains textual definitions. </pre>
			</div>
				
			<p class="syntax">
				Grey boxes such as this include syntax rules that apply to the shapes graph.
			</p>
				
			<p>
				<code>true</code> denotes the RDF term <code>"true"^^xsd:boolean</code>.
				<code>false</code> denotes the RDF term <code>"false"^^xsd:boolean</code>.
			</p>
		</section>
		
		<section class="introductory">
			<h2>Terminology</h2>
			<p>
				The terminology used throughout this document is consistent with the definitions in the
				main SHACL [[!shacl]] specification, which references terms from RDF [[!rdf11-concepts]].
				This includes the terms
				<dfn data-lt="bindings"><a href="https://www.w3.org/TR/shacl/#dfn-binding">binding</a></dfn>,
				<dfn data-lt="blank nodes"><a href="https://www.w3.org/TR/shacl/#dfn-blank-node">blank node</a></dfn>,
				<dfn data-lt="conform|conforms"><a href="https://www.w3.org/TR/shacl/#dfn-conforms">conformance</a></dfn>,
				<dfn data-lt="constraints"><a href="https://www.w3.org/TR/shacl/#dfn-constraint">constraint</a></dfn>,
				<dfn data-lt="constraint components"><a href="https://www.w3.org/TR/shacl/#dfn-constraint-component">constraint component</a></dfn>,
				<dfn data-lt="data graphs"><a href="https://www.w3.org/TR/shacl/#dfn-data-graph">data graph</a></dfn>,
				<dfn data-lt="datatypes"><a href="https://www.w3.org/TR/shacl/#dfn-datatype">datatype</a></dfn>,
				<dfn data-lt="failures"><a href="https://www.w3.org/TR/shacl/#dfn-failure">failure</a></dfn>,
				<dfn data-lt="focus nodes"><a href="https://www.w3.org/TR/shacl/#dfn-focus-node">focus node</a></dfn>,
				<dfn data-lt="RDF graphs|graphs|graph"><a href="https://www.w3.org/TR/shacl/#dfn-rdf-graph">RDF graph</a></dfn>,
				<dfn><a href="https://www.w3.org/TR/shacl/#dfn-ill-formed">ill-formed</a></dfn>,
				<dfn data-lt="IRIs"><a href="https://www.w3.org/TR/shacl/#dfn-iri">IRI</a></dfn>,
				<dfn data-lt="literals"><a href="https://www.w3.org/TR/shacl/#dfn-literal">literal</a></dfn>,
				<dfn data-lt="local names"><a href="https://www.w3.org/TR/shacl/#dfn-local-name">local name</a></dfn>,
				<dfn data-lt="members"><a href="https://www.w3.org/TR/shacl/#dfn-members">member</a></dfn>,
				<dfn data-lt="nodes|RDF node"><a href="https://www.w3.org/TR/shacl/#dfn-node">node</a></dfn>,
				<dfn data-lt="node shapes"><a href="https://www.w3.org/TR/shacl/#dfn-node-shape">node shape</a></dfn>,
				<dfn data-lt="objects"><a href="https://www.w3.org/TR/shacl/#dfn-object">object</a></dfn>,
				<dfn data-lt="parameters"><a href="https://www.w3.org/TR/shacl/#dfn-parameters">parameter</a></dfn>,
				<dfn data-lt="pre-bind|pre-bound"><a href="https://www.w3.org/TR/shacl/#pre-binding">pre-binding</a></dfn>,
				<dfn data-lt="predicates"><a href="https://www.w3.org/TR/shacl/#dfn-predicate">predicate</a></dfn>,
				<dfn data-lt="property paths"><a href="https://www.w3.org/TR/shacl/#dfn-shacl-property-path">property path</a></dfn>,
				<dfn data-lt="property shapes"><a href="https://www.w3.org/TR/shacl/#dfn-property-shape">property shape</a></dfn>,
				<dfn data-lt="RDF terms|terms|term"><a href="https://www.w3.org/TR/shacl/#dfn-rdf-term">RDF term</a></dfn>,
				<dfn data-lt="SHACL instances"><a href="https://www.w3.org/TR/shacl/#dfn-shacl-instance">SHACL instance</a></dfn>,
				<dfn data-lt="SHACL lists"><a href="https://www.w3.org/TR/shacl/#dfn-shacl-list">SHACL list</a></dfn>,
				<dfn data-lt="SHACL subclasses"><a href="https://www.w3.org/TR/shacl/#dfn-shacl-subclass">SHACL subclass</a></dfn>,
				<dfn data-lt="shapes"><a href="https://www.w3.org/TR/shacl/#dfn-shape">shape</a></dfn>,
				<dfn data-lt="shapes graphs"><a href="https://www.w3.org/TR/shacl/#dfn-shapes-graph">shapes graph</a></dfn>,
				<dfn data-lt="solutions"><a href="https://www.w3.org/TR/shacl/#dfn-solution">solution</a></dfn>,
				<dfn data-lt="subjects"><a href="https://www.w3.org/TR/shacl/#dfn-subject">subject</a></dfn>,
				<dfn data-lt="targets"><a href="https://www.w3.org/TR/shacl/#dfn-target">target</a></dfn>,
				<dfn data-lt="triples"><a href="https://www.w3.org/TR/shacl/#dfn-rdf-triple">triple</a></dfn>,
				<dfn><a href="https://www.w3.org/TR/shacl/#dfn-validation">validation</a></dfn>,
				<dfn data-lt="validation reports"><a href="https://www.w3.org/TR/shacl/#dfn-validation-report">validation report</a></dfn>,
				<dfn data-lt="validation results"><a href="https://www.w3.org/TR/shacl/#dfn-validation-results">validation result</a></dfn>,
				<dfn data-lt="validators"><a href="https://www.w3.org/TR/shacl/#dfn-validators">validator</a></dfn>,
				<dfn data-lt="values"><a href="https://www.w3.org/TR/shacl/#dfn-value">value</a></dfn>,
				<dfn data-lt="value nodes"><a href="https://www.w3.org/TR/shacl/#dfn-value-nodes">value node</a></dfn>.
			</p>
		</section>

		<section id="intro">
			<h2>Introduction</h2>
			<p>
				The SHACL specification [[!shacl]] is divided into SHACL Core and SHACL-SPARQL:
			</p>
			<ul>	  
				<li>
					<strong>SHACL Core</strong> consists of frequently needed features for the representation of <a>shapes</a>,
					<a>constraints</a> and <a>targets</a>.
				</li> 
				<li>
					<strong>SHACL-SPARQL</strong> consists of all features of SHACL Core plus the expressive power of
					SPARQL-based <a>constraints</a> and an extension mechanism to declare new <a>constraint components</a>.
				</li>
			</ul>
	 		<p>
	 			This document extends the functionality of SHACL by defining RDF vocabularies to cover the following features:
	 		</p>
	 		<ul>
	 			<li><b><a>Custom Targets</a></b> - add flexibility to selecting the <a>focus nodes</a> of <a>shapes</a></li>
	 			<li><b><a>Annotation Properties</a></b> - can create extra values in validation reports</li>
	 			<li><b><a>SHACL Functions</a></b> - encapsulate complex operations into reusable building blocks</li>
	 			<li><b><a>Node Expressions</a></b> - describe how to derive sets of <a>nodes</a></li>
	 			<li><b><a>Expression Constraints</a></b> - enable constraint checks based on node expressions</li>
	 			<li><b><a>SHACL Rules</a></b> - enable deriving new <a>triples</a> from existing ones</li>
	 		</ul>
	 		<p>
	 			Taken together or individually, these features greatly extend the application scenarios of SHACL, and
	 			SHACL-SPARQL in particular.
	 		</p>
		</section>

		<section id="conformance">
	 		<p>
	 			Some of the features presented here (including <a>node expressions</a>, <a>expression constraints</a>
	 			and <a>triple rules</a>) do not necessarily require a SPARQL processor and could be used as extensions of
	 			pure SHACL Core implementations.
	 			Other features (including <a href="#SPARQLTargetType">custom target types</a>, <a>SHACL functions</a>,
	 			and general <a>SHACL rules</a>) define extension mechanisms that can also be used with other languages
	 			than SPARQL, such as JavaScript (as defined by the SHACL-JS document [[shacl-js]]).
	 		</p>
			<p>
				A SHACL-SPARQL processor that also supports all features defined in this document and is called
				an <dfn>Advanced SHACL-SPARQL</dfn> processor.
			</p>
		</section>		

		<section id="targets">
			<h2>Custom Targets</h2>
			<p>
				In general, <a>targets</a> define a mechanism that is used by SHACL engines to determine the <a>focus nodes</a>
				that should be validated against a given <a>shape</a>.
				SHACL Core [[!shacl]] defines a fixed set of Core <a>targets</a> by means of properties such as <code>sh:targetClass</code>.
				These Core targets were designed to cover a large number of use cases while retaining a simple declarative data model.
				However, in some use cases, these Core targets are not sufficient. For example it is impossible to state that
				a shape should apply only to a subset of instances of a class, e.g. persons born in the USA.
				Neither is it possible to state that a shape should apply to all subjects in a graph, or to nodes selected by completely
				different, application-specific mechanisms.
			</p>
			<p>
				This section defines richer mechanisms to define <a>targets</a>, called <dfn data-lt="custom target">custom targets</dfn>.
				Custom targets are the <a>values</a> of the property <code>sh:target</code> in the <a>shapes graph</a>.
				The property <code>sh:target</code> has a similar status as, for example, <code>sh:targetClass</code>,
				and all <a>subjects</a> of <code>sh:target</code> <a>triples</a> are also <a>shapes</a>.
			</p>
			<p class="syntax">
				<span data-syntax-rule="target-nodeKind">The <a>values</a> of <code>sh:target</code> at a <a>shape</a> are
				<a>IRIs</a> or <a>blank nodes</a>.</span>
			</p>
			<p>
				A SHACL engine that supports <a>custom targets</a> uses the <a>values</a> of the <a>custom target</a> node
				to compute the target nodes for the associated <a>shape</a>.
				The algorithm that is used for this computation depends on the <code>rdf:type</code> of the <a>custom target</a>.
				The following sub-sections define two such algorithms:
			</p>
			<ul>
				<li><a>SPARQL-based targets</a></li>
				<li><a>SPARQL-based target types</a></li>
			</ul>
			<p>
				However, other types of targets can be supported by other extension languages such as JavaScript.
				The class <code>sh:Target</code> is the recommended base class for such extensions.
			</p>
			<p>
				The behavior of a SHACL engine that is unable to handle a given <a>custom target</a> is left undefined.
				SHACL Core processors do not even need to be aware of the existence of the <code>sh:target</code> property.
				Engines that are aware of this property and cannot handle a given <a>custom target</a> SHOULD at least report a warning.
			</p>
			<section id="SPARQLTarget">
				<h3>SPARQL-based Targets</h3>
				<p>
					<a>Custom targets</a> that are <a>SHACL instances</a> of <code>sh:SPARQLTarget</code> are called
					<dfn data-lt="SPARQL-based target">SPARQL-based targets</dfn>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="SPARQLTarget-select-count"><a>SPARQL-based targets</a> have exactly one <a>value</a> for the property <code>sh:select</code>.</span>
					<span data-syntax-rule="SPARQLTarget-prefixes-nodeKind"><a>SPARQL-based targets</a> may have <a>values</a> for the property <code>sh:prefixes</code>
					and these values are <a>IRIs</a> or <a>blank nodes</a>.</span>
					<span data-syntax-rule="SPARQLTarget-select-sparql">Using the <a>values</a> of <code>sh:prefixes</code> as defined by
					<a href="https://www.w3.org/TR/shacl/#sparql-prefixes">5.2.1 Prefix Declarations for SPARQL Queries</a>,
					the <a>values</a> of <code>sh:select</code> must be valid SPARQL 1.1 SELECT queries with a single result variable <code>this</code>.</span>
					<span data-syntax-rule="SPARQLTarget-ask-count"><a>SPARQL-based targets</a> have at most one <a>value</a> for the property <code>sh:ask</code>.</span>
				</p>
				<p>
					The following example declares a well-formed SPARQL-based target that produces all persons born in the USA:
				</p>
				<pre class="example-shapes" title="SPARQL-based target example">
ex:
	sh:declare [
		sh:prefix &quot;ex&quot; ;
		sh:namespace "http://example.com/ns#"^^xsd:anyURI ;
	] .
				
ex:USCitizenShape
	a sh:NodeShape ;
	sh:target [
		a sh:SPARQLTarget ;
		sh:prefixes ex: ;
		sh:select """
			SELECT ?this
			WHERE {
				?this a ex:Person .
				?this ex:bornIn ex:USA .
			}
			""" ;
	] ;
	...</pre>
				<div class="def def-text">
					<div class="def-header">TEXTUAL DEFINITION</div>
					<div class="def-text-body">
						Let <code>Q</code> be the SPARQL SELECT query derived from the <a>values</a> of <code>sh:select</code>
						and <code>sh:prefixes</code> of the <a>SPARQL-based target</a> <code>T</code>.
						The <a>target</a> nodes of <code>T</code> are the <a>bindings</a> of the variable <code>this</code> returned
						by <code>Q</code> against the <a>data graph</a>.
					</div>
				</div>
				<p>
					While the SELECT queries can be used to identify all <a>focus nodes</a> for a given <a>shape</a>, SHACL processors sometimes
					also need to compute the inverse direction and find all <a>shapes</a> for which a given <a>node</a> needs to be validated against.
					For this reason, the following semantic restriction is recommended for SELECT queries used in SPARQL-based targets.
					Informally, SHACL Full processors should be able to derive an equivalent ASK query from the SELECT query,
					<a>pre-bind</a> the potential <a>focus node</a>,
					and check whether the potential focus node needs to be validated against the <a>shape</a> that has the given target.
					Formally, let <code>A</code> be a SPARQL ASK query that is produced by replacing the <a href="https://www.w3.org/TR/sparql11-query/#rSelectClause">SelectClause</a>
					with <code>ASK</code> in the outermost SELECT query.
					Let <code>rs</code> be the set of RDF terms returned as <a>bindings</a> for the variable <code>this</code> in the <a>solutions</a> of the SELECT query.
					Then <code>A</code> returns <code>true</code> if and only if the variable <code>this</code> is <a>pre-bound</a> with a value from <code>rs</code>.
					If the SELECT query of a SPARQL-based target does not fulfill this requirement, it needs to be accompanied
					by a SPARQL ASK query as the value for <code>sh:ask</code>.
					A SHACL engine can then determine whether a given <a>shape</a> applies to a given <a>node</a> by executing the ASK
					query with the variable <code>this</code> <a>pre-bound</a> to the <a>node</a>.
					If the ASK query evaluates to <code>true</code> then the <a>node</a> is in the target of the <a>shape</a>.
				</p>
			</section>
			<section id="SPARQLTargetType">
				<h3>SPARQL-based Target Types</h3>
				<p>
					In some cases it would be too repetitive to declare SPARQL-based targets with similar SPARQL queries that only differ
					in a few aspects.
					SHACL-SPARQL defines a mechanism for user-defined <a>constraint components</a>, allowing users to reuse the same
					SPARQL query in a parameterized form.
					The SPARQL-based target types introduced in this section follow a similar design.
				</p>
				<p>
					The class <code>sh:TargetType</code> can be used to declare high-level vocabularies for targets in a <a>shapes graph</a>.
					The class <code>sh:SPARQLTargetType</code> is declared as <code>rdfs:subClassOf sh:TargetType</code> for
					<dfn>SPARQL-based target types</dfn>.
					Other extension languages may define alternative execution instructions for target types with the same IRI,
					making them potentially more platform independent than pure <a>SPARQL-based targets</a>.
					Instances of the class <code>sh:SPARQLTargetType</code> specify a SPARQL SELECT query via the property <code>sh:select</code>,
					and this query has to fulfill the same syntactic and semantic rules as <a href="#SPARQLTarget">SPARQL-based targets</a>.
				</p>
				<p>
					Similar to SPARQL-based <a>constraint components</a>, such targets take <a>parameters</a> and
					the parameter values become <a>pre-bound</a> variables in the associated SPARQL queries.
					The parameter values of such targets cannot not be blank nodes, and the same target cannot have more than one value per parameter.
					A target that lacks a <a>value</a> for a non-optional parameter is ignored, producing no target nodes.
					Similar to SPARQL-based <a>constraint components</a>, target types may also have values for the property <code>sh:labelTemplate</code>.
				</p>
				<p>
					The following example declares a new SPARQL-based target type that takes one parameter <code>ex:country</code>
					that gets mapped into the variable <code>country</code> in the corresponding SPARQL query to determine the resulting target nodes.
				</p>
				<pre class="example-shapes">
ex:BornInCountryTarget
	a sh:SPARQLTargetType ;
	rdfs:subClassOf sh:Target ;
	sh:labelTemplate "All persons born in {$country}" ;
	sh:parameter [
		sh:path ex:country ;
		sh:description "The country that the focus nodes are 'born' in." ;
		sh:class ex:Country ;
		sh:nodeKind sh:IRI ;
	] ;
	sh:select """
		PREFIX ex: &lt;http://example.com/ns#&gt;
		SELECT ?this
		WHERE {
			?this a ex:Person .
			?this ex:bornIn $country .
		}
		""" .</pre>
				<p>
					Once such a target type has been defined in a <a>shapes graph</a>, it can be used by multiple shapes:
				</p>
				<pre class="example-shapes">
ex:GermanCitizenShape
	a sh:NodeShape ;
	sh:target [
		a ex:PeopleBornInCountryTarget ;
		ex:country ex:Germany ;
	] ;
	...
	
ex:USCitizenShape
	a sh:NodeShape ;
	sh:target [
		a ex:PeopleBornInCountryTarget ;
		ex:country ex:USA ;
	] ;
	...</pre>
				<p>
					The set of focus nodes produced by such a target type consists of all bindings of the variable <code>this</code> in the result set,
					when the SPARQL SELECT query has been executed with the <a>pre-bound</a> parameter values.
				</p>
			</section>
		</section>
		
		<section id="sparql-constraints-annotations">
			<h2>Annotation Properties</h2>
			<p>
				This section extends the general <a href="https://www.w3.org/TR/shacl/#sparql-constraints-variables">mechanism from SHACL-SPARQL</a>
				[[!shacl]] to produce <a>validation reports</a> as a result of the <a>validation</a>.
			</p>
			<p>
				Implementations that support this feature make it possible to inject so-called <dfn>annotation properties</dfn>
				into the validation result nodes created for each <a>solution</a> produced by the SELECT queries of a
				SPARQL-based <a>constraint</a> or <a>constraint component</a>.
				Any such annotation property needs to be declared via a <a>value</a> of <code>sh:resultAnnotation</code> at
				the <a>subject</a> of the <code>sh:select</code> or <code>sh:ask</code> <a>triple</a>.
			</p>
			<p class="syntax">
				<span data-syntax-rule="resultAnnotation-nodeKind">The <a>values</a> of <code>sh:resultAnnotation</code> are
				called <dfn data-lt="result annotation">result annotations</dfn> and are either <a>IRIs</a> or <a>blank nodes</a></span>.
			</p>
			<p>
				<a>Result annotations</a> have the following properties:
			</p>
			<table class="term-table">
				<tr>
					<th>Property</th>
					<th>Summary and Syntax Rules</th>
				</tr>
				<tr>
					<td><code>sh:annotationProperty</code></td>
					<td>
						The property that shall be set.
						<span data-syntax-rule="annotationProperty">Each <a>result annotation</a> has exactly one <a>value</a>
						for the property <code>sh:annotationProperty</code> and this value is an <a>IRI</a>.</span>
					</td>
				</tr>
				<tr>
					<td><code>sh:annotationVarName</code></td>
					<td>
						The name of the SPARQL variable to take the annotation values from.
						<span data-syntax-rule="annotationVarName">Each <a>result annotation</a> has at most 1 <a>value</a>
						for the property <code>sh:annotationVarName</code> and this <a>value</a> is <a>literal</a> with
						<a>datatype</a> <code>xsd:string</code>.</span>
					</td>
				</tr>
				<tr>
					<td><code>sh:annotationValue</code></td>
					<td>
						Constant <a>RDF terms</a> that shall be used as default values.
					</td>
				</tr>
			</table>
			<p>
				For each <a>solution</a> of a SELECT result set, a SHACL processor that supports annotations
				walks through the declared result annotations.
				The mapping from result annotations to SPARQL variables uses the following rules:
			</p>
			<ol>
				<li>Use the <a>value</a> of the property <code>sh:annotationVarName</code></li>
				<li>If no such <a>value</a> exists, use the <a>local name</a> of the <a>value</a> of <code>sh:annotationProperty</code> 
				as the variable name</li>
			</ol>
			<p>
				If a variable name could be determined, then the SHACL processor copies the <a>binding</a> for the given variable
				as a value for the property specified using <code>sh:annotationProperty</code> 
				into the validation result that is being produced for the current <a>solution</a>.
				If the variable has no <a>binding</a> in the result set <a>solution</a>,
				then the <a>values</a> of <code>sh:annotationValue</code> is used, if present.
			</p>
			<p>
				Here is an example illustrating the use of result annotations.
			</p>
			<pre class="example-shapes">
ex:AnnotationExample
	a sh:NodeShape ;
	sh:targetNode ex:ExampleResource ;
	sh:sparql [   # _:b1
		sh:resultAnnotation [
			sh:annotationProperty ex:time ;
			sh:annotationVarName "time" ;
		] ;
		sh:select """
			SELECT $this ?message ?time
			WHERE {
				BIND (CONCAT("The ", "message.") AS ?message) .
				BIND (NOW() AS ?time) .
			}
			""" ;
	] .</pre>
			<p>
				Validation produces the following validation report:
			</p>
			<pre class="example-results">
[	a sh:ValidationReport ;
	sh:conforms false ;
	sh:result [
		a sh:ValidationResult ;
		sh:focusNode ex:ExampleResource ;
		sh:resultMessage "The message." ;
		sh:resultSeverity sh:Violation ;
		sh:sourceConstraint _:b1 ;
		sh:sourceConstraintComponent sh:SPARQLConstraintComponent ;
		sh:sourceShape ex:AnnotationExample ;
		ex:time "2015-03-27T10:58:00"^^xsd:dateTime ;  # Example
	]
] .</pre>
		</section>
		
		<section id="functions">
			<h2>SHACL Functions</h2>
			<p>
				<dfn data-lt="function|functions|SHACL function">SHACL functions</dfn> declare operations that produce an <a>RDF term</a>
				based on zero or more <a>parameters</a> and a <a>data graph</a>.
				Each SHACL function has an <a>IRI</a>.
				The actual execution logic (or algorithm) of a SHACL function can be declared in a variety of execution languages.
				This document defines one specific kind of SHACL functions, the <a>SPARQL-based functions</a>.
				JavaScript-based Functions are defined in the separate SHACL-JS document [[shacl-js]].
				The same function <a>IRI</a> can potentially be executed on a multitude of platforms, if it declares
				execution instructions for these platforms.
			</p>
			<p>
				SHACL functions can be called within FILTER or BIND clauses and similar features of SPARQL queries.
				SHACL functions can also be used declaratively in frameworks such as the SHACL <a>node expressions</a>
				which are used in <a>SHACL rules</a>.
				In those scenarios they may be used to perform data transformations such as string concatenation.
			</p>
			<section id="functions-example">
				<h3>An Example SHACL Function</h3>
				<p>
					The following example illustrates the declaration of a SHACL function based on a simple mathematical SPARQL query.
				</p>
				<pre class="example-shapes" title="SHACL function with a SPARQL body">
ex:multiply
	a sh:SPARQLFunction ;
	rdfs:comment "Multiplies its two arguments $op1 and $op2." ;
	sh:parameter [
		sh:path ex:op1 ;
		sh:datatype xsd:integer ;
		sh:description "The first operand" ;
	] ;
	sh:parameter [
		sh:path ex:op2 ;
		sh:datatype xsd:integer ;
		sh:description "The second operand" ;
	] ;
	sh:returnType xsd:integer ;
	sh:select """
		SELECT ($op1 * $op2 AS ?result)
		WHERE {
		}
		""" .</pre>
				<p>
					Using the declaration above, SPARQL engines that support SHACL functions install a new SPARQL function based on the
					SPARQL 1.1 <a href="http://www.w3.org/TR/sparql11-query/#extensionFunctions">Extensible Value Testing</a> mechanism.
					Such engines are then able to handle expressions such as <code>ex:multiply(7, 8)</code>, producing <code>56</code>,
					as illustrated in the following SPARQL query.
				</p>
				<pre class="example-other" title="Call of a SHACL function in a SPARQL query">
SELECT ?subject ?area
WHERE {
	?subject ex:width ?width .
	?subject ex:height ?height .
	BIND (ex:multiply(?width, ?height) AS ?area) .
}</pre>
				<p>
					The following sections introduce the general properties that such functions may have,
					before the specific characteristics of <a>SPARQL-based functions</a> are defined.
				</p>
			</section>
			<section id="function-parameters">
				<h3>Function Parameters</h3>
				<p>
					The parameters of a <a>SHACL function</a> are declared using the property <code>sh:parameter</code>.
					This corresponds closely to the <a href="https://www.w3.org/TR/shacl/#constraint-components-parameters">parameter
					declarations of SPARQL-based constraint components</a>, and the same syntax rules apply.
				</p>
				<p id="parameters-ordering">
					Parameters are ordered, corresponding to the notation of function calls in SPARQL such as
					<code>ex:exampleFunction(?param1, ?param2)</code>.
					The ordering of function parameters is determined as follows:
				</p>
				<ul>
					<li>
						If any of the parameters have a <a>value</a> for <code>sh:order</code> then all of them
						are ordered in ascending order by the parameters' numeric <a>values</a> of <code>sh:order</code>,
						using <code>0</code> as default value if unspecified.
					</li>
					<li>
						If none of the parameters have a <a>value</a> for <code>sh:order</code> then all of them
						are ordered in ascending order of the <a>local names</a> of their declared <code>sh:path</code> values.
					</li>
				</ul>
				<p>
					Each parameter may have its property <code>sh:optional</code> set to <code>true</code>
					to indicate that the parameter is not mandatory.
					If a function gets invoked without all its mandatory parameters then it returns no result node
					(an error in SPARQL, producing unbound in a BIND statement).
				</p>
			</section>
			<section id="function-returnType">
				<h3>sh:returnType</h3>
				<p>
					A function may declare a single <dfn>return type</dfn> via <code>sh:returnType</code>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="returnType-maxCount">A function has at most one <a>value</a> for <code>sh:returnType</code>.</span>
					<span data-syntax-rule="returnType-nodeKind">The values of <code>sh:returnType</code> are <a>IRIs</a>.</span>
				</p>
				<p>
					The <a>return type</a> may serve for documentation purposes only.
					However, in some execution languages such as JavaScript, the declared <code>sh:returnType</code> may inform
					a processor how to cast a native value into an <a>RDF term</a>.
				</p>
			</section>
			<section id="SPARQLFunction">
				<h3>SPARQL-based Functions</h3>
				<p>
					<a>SHACL instances</a> of <code>sh:SPARQLFunction</code> that are <a>IRIs</a> in a <a>shapes graph</a>
					are called <dfn>SPARQL-based functions</dfn>.
				</p>
				<p class="syntax">
					<span data-syntax-rule="SPARQLFunction-query"><a>SPARQL-based functions</a> have exactly one <a>value</a> for either <code>sh:ask</code> or <code>sh:select</code>.
					The <a>values</a> of these properties are strings that can be parsed into SPARQL queries of type ASK (for <code>sh:ask</code>)
					or SELECT (for <code>sh:select</code>) using the SHACL-SPARQL <a href="https://www.w3.org/TR/shacl/#sparql-prefixes">prefix declaration mechanism</a>.
					SELECT queries return exactly one result variable and do not use the <code>SELECT *</code> syntax.</span>
				</p>
				<p>
					When the function is executed, the SPARQL processor needs to <a>pre-bind</a> variables based on the provided arguments
					of the function call.
					In the <a href="#functions-example">SHACL functions example</a> above, the value for the parameter declared as
					<code>ex:op1</code> is <a>pre-bound</a> to the SPARQL variable <code>$op1</code>, etc.
					For ASK queries, the function's return value is the result of the ASK query execution, i.e. <code>true</code> or <code>false</code>.
					For SELECT queries, the function's return value is the <a>binding</a> of the (single) result variable of the first <a>solution</a> in the result set.
					Since all other bindings will be ignored, such SELECT queries should only return at most one <a>solution</a>.
					If the result variable is unbound, then the function generates a <a href="https://www.w3.org/TR/sparql11-query/#invocation">SPARQL error</a>.
				</p>
			</section>
		</section>
		
		<section id="node-expressions">
			<h2>Node Expressions</h2>
			<p>
				This section defines a feature called <dfn data-lt="node expression">node expressions</dfn>.
				Node expressions are declared as RDF nodes in a <a>shapes graph</a> and instruct a SHACL engine
				how to compute a list of <a>nodes</a> for a given <a>focus node</a>.
				Each <a>node expression</a> has one of the following types,
				each of which is defined together with its evaluation semantics in the following sub-sections.
			</p>
			<table class="term-table">
				<tr>
					<th>Node&nbsp;Expression&nbsp;Type</th>
					<th>Syntax (Informative)</th>
					<th>Summary (Informative)</th>
				</tr>
				<tr>
					<td><a>Focus Node Expression</a></td>
					<td><code>sh:this</code></td>
					<td>The list consisting of the current <a>focus node</a>.</td>
				</tr>
				<tr>
					<td><a>Constant&nbsp;Term&nbsp;Expression</a></td>
					<td>Any <a>IRI</a> or <a>literal</a> except <code>sh:this</code></td>
					<td>The list consisting of the given <a>term</a>.</td>
				</tr>
				<tr>
					<td><a>Function Expression</a></td>
					<td><a>Blank node</a> with a list-valued triple</td>
					<td>The results of evaluating a given <a>SHACL Function</a>.</td>
				</tr>
				<tr>
					<td><a>Path Expression</a></td>
					<td><a>Blank node</a> with <code>sh:path</code></td>
					<td>The <a>values</a> of a given <a>property path</a>.</td>
				</tr>
				<tr>
					<td><a>Exists Expression</a></td>
					<td><a>Blank node</a> with <code>sh:exists</code></td>
					<td>The list consisting of either <code>true</code> or <code>false</code> depending on whether input nodes exist.</td>
				</tr>
				<tr>
					<td><a>If Expression</a></td>
					<td><a>Blank node</a> with <code>sh:if</code></td>
					<td>The results of either <code>sh:then</code> or <code>sh:else</code> depending on whether the <code>sh:if</code> node expression is [<code>true</code>].</td>
				</tr>
				<tr>
					<td><a>Filter Shape Expression</a></td>
					<td><a>Blank node</a> with <code>sh:filterShape</code></td>
					<td>The sub-list of the input nodes that conform to a given <a>shape</a>.</td>
				</tr>
				<tr>
					<td><a>Intersection Expression</a></td>
					<td><a>Blank node</a> with <code>sh:intersection</code></td>
					<td>The intersection of two or more input node lists.</td>
				</tr>
				<tr>
					<td><a>Union Expression</a></td>
					<td><a>Blank node</a> with <code>sh:union</code></td>
					<td>The union (concatenation) of two or more input node lists.</td>
				</tr>
				<tr>
					<td><a>Minus Expression</a></td>
					<td><a>Blank node</a> with <code>sh:minus</code> and <code>sh:nodes</code></td>
					<td>The input nodes except those that are in another "minus" list.</td>
				</tr>
				<tr>
					<td><a>Distinct Expression</a></td>
					<td><a>Blank node</a> with <code>sh:distinct</code></td>
					<td>The sub-list of the input nodes that are distinct, eliminating duplicates.</td>
				</tr>
				<tr>
					<td><a>Count Expression</a></td>
					<td><a>Blank node</a> with <code>sh:count</code></td>
					<td>The number of input nodes as a single <code>xsd:integer</code> node.</td>
				</tr>
				<tr>
					<td><a>Min Expression</a></td>
					<td><a>Blank node</a> with <code>sh:min</code></td>
					<td>The smallest of the input nodes.</td>
				</tr>
				<tr>
					<td><a>Max Expression</a></td>
					<td><a>Blank node</a> with <code>sh:max</code></td>
					<td>The largest of the input nodes.</td>
				</tr>
				<tr>
					<td><a>Sum Expression</a></td>
					<td><a>Blank node</a> with <code>sh:sum</code></td>
					<td>The sum of the input nodes.</td>
				</tr>
				<tr>
					<td><a>Group Concat Expression</a></td>
					<td><a>Blank node</a> with <code>sh:groupConcat</code></td>
					<td>A string concatenation of all input nodes.</td>
				</tr>
				<tr>
					<td><a>OrderBy Expression</a></td>
					<td><a>Blank node</a> with <code>sh:orderBy</code> and <code>sh:nodes</code></td>
					<td>The input nodes, ordered by a given expression.</td>
				</tr>
				<tr>
					<td><a>Limit Expression</a></td>
					<td><a>Blank node</a> with <code>sh:limit</code> and <code>sh:nodes</code></td>
					<td>Only the first N of the input nodes.</td>
				</tr>
				<tr>
					<td><a>Offset Expression</a></td>
					<td><a>Blank node</a> with <code>sh:offset</code> and <code>sh:nodes</code></td>
					<td>The input nodes except the first N ones.</td>
				</tr>
				<tr>
					<td><a>SPARQL ASK Expression</a></td>
					<td><a>Blank node</a> with <code>sh:ask</code>.</td>
					<td>An <code>xsd:boolean</code> based on the result of a SPARQL ASK query.</td>
				</tr>
				<tr>
					<td><a>SPARQL SELECT Expression</a></td>
					<td><a>Blank node</a> with <code>sh:select</code>.</td>
					<td>The results of a SPARQL SELECT query.</td>
				</tr>
			</table>
			<p>
				The basic idea of these expressions is that they can be used to derive a list of RDF nodes from
				a given <a>focus node</a>, for example all values of a given property of the focus node.
				Some of these expressions can use the output of another expression as their input,
				leading to evaluation chains and trees.
			</p>
			<p>
				The following example declares a <a>node expression</a> that produces the display labels of all values of
				the property <code>ex:customer</code> that <a>conform</a> to a given <a>shape</a> <code>ex:GoodCustomerShape</code>.
				The assumption here is that there is a <a>SHACL function</a> <code>ex:displayLabel</code> which declares a
				single parameter.
			</p>
			<pre class="example-shapes" title="Node expression example">
[
	ex:displayLabel ( [
		sh:filterShape ex:GoodCustomerShape ;
		sh:nodes [ sh:path ex:customer ] ;
	] )
] .</pre>
			<p>
				To evaluate this example, an engine gets all <a>values</a> of <code>ex:customer</code> of the <a>focus node</a>,
				then filters them according to the <a>shape</a> <code>ex:GoodCustomerShape</code>
				and repeatedly calls the <a>SHACL function</a> <code>ex:displayLabel</code> with all values that pass the
				filter shape as arguments.
			</p>
			<p>
				Important use cases of such expressions are <a>expression constraints</a> and <a>SHACL rules</a>,
				yet the basic functionality and vocabulary may find many other application areas.
			</p>
			<p>
				Each of the following sub-sections defines a node expression type with its syntax rules 
				and evaluation semantics based on a mapping operation <code>Eval($expr, $this)</code> where the
				first argument <code>$expr</code> is the given expression, <code>$this</code> is the current <a>focus node</a>
				and which produces a list of RDF nodes.
				Unless specified otherwise, the members of these lists are handled in their natural order.
			</p>
			<p class="syntax">
				<span data-syntax-rule="node-expressions-recursion">A <code>node expression</code> cannot recursively have itself
				as a "nested" node expression, e.g. as <a>value</a> of <code>sh:nodes</code>.</span>
			</p>

			<section id="node-expressions-focus">
				<h3>Focus Node Expressions</h3>
				<p>
					The <a>IRI</a> <code>sh:this</code> is the (only) node declaring a <dfn>focus node expression</dfn>.
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF FOCUS NODE EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>focus node expression</a> <code>sh:this</code>, <code>Eval(sh:this, $this)</code> produces
						the list of length 1 with <code>$this</code> as its only member.
					</div>
				</div>
			</section>

			<section id="node-expressions-constant">
				<h3>Constant Term Expressions</h3>
				<p>
					Any <a>literal</a> or <a>IRI</a> except <code>sh:this</code> declares a <dfn>constant term expression</dfn>.
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF CONSTANT TERM EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>constant term expression</a> <code>$expr</code>, <code>Eval($expr, $this)</code> produces
						the list of length 1 with <code>$expr</code> as its only member.
					</div>
				</div>
			</section>

			<section id="node-expressions-exists">
				<h3>Exists Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="ExistsExpression">An <dfn>exists expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for <code>sh:exists</code> (which is a well-formed <a>shape</a>).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF EXISTS EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>exists expression</a> <code>$expr</code> with <code>N</code> being the <a>node expression</a> that
						is the <a>value</a> of <code>sh:exists</code>, <code>Eval($expr, $this)</code> produces the list consisting of exactly the node <code>true</code>
						if <code>Eval(N, $this)</code> produces at least one <a>node</a>, and the list consisting of exactly the node <code>false</code> otherwise.
					</div>
				</div>
				<p>
					In the following example, <code>sh:exists</code> is used to test whether the current focus node has any value for an example property.
                    This is comparable to the SPARQL expression on the right.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[
    sh:exists [ sh:path ex:someProperty ]
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
{
    BIND (EXISTS { $this ex:someProperty ?any } AS ?result)
}
</pre>
						</td>
					</tr>
				</table>
			</section>

			<section id="node-expressions-if">
				<h3>If Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="IfExpression">An <dfn>if expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for <code>sh:if</code> (which is a well-formed <a>node expression</a>),
					at most one <a>value</a> for <code>sh:then</code> (which is a well-formed <a>node expression</a>)
					and at most one <a>value</a> for <code>sh:else</code> (which is a well-formed <a>node expression</a>).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF IF EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>if expression</a> <code>$expr</code> with <code>IF</code> being the <a>node expression</a> that
						is the <a>value</a> of <code>sh:if</code>, and <code>THEN</code> and <code>ELSE</code> being corresponding
						<a>values</a> of <code>sh:then</code> and <code>sh:else</code>, resp.
						If <code>Eval(IF, $this)</code> produces the list consisting of exactly the node <code>true</code>
						then produce <code>Eval(THEN, $this)</code> (or the empty list if THEN is absent),
						otherwise produce <code>Eval(ELSE, $this)</code> (or the empty list if ELSE is absent).
					</div>
				</div>
				<p>
					The following example produces the string node "married" if the focus node has a spouse, "not married" otherwise.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[
    sh:if [ sh:exists [ sh:path ex:spouse ] ] ;
    sh:then "married" ;
    sh:else "not married" ;
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
{
    BIND (IF(EXISTS { $this ex:spouse ?any }, 
            "married", 
            "not married") AS ?result)
}
</pre>
						</td>
					</tr>
				</table>
			</section>

			<section id="node-expressions-filter-shape">
				<h3>Filter Shape Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="FilterShapeExpression">A <dfn>filter shape expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for <code>sh:filterShape</code> (which is a well-formed <a>shape</a>)
					and at most one <a>value</a> for <code>sh:nodes</code> (which is a well-formed <a>node expression</a>).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF FILTER SHAPE EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>filter shape expression</a> <code>$expr</code> with <code>S</code> being the <a>shape</a>
						that is the <a>value</a> of <code>sh:filterShape</code> and <code>N</code> being the <a>node expression</a> that
						is the <a>value</a> of <code>sh:nodes</code> (defaulting to the <a>focus node expression</a> if absent), <code>Eval($expr, $this)</code> produces the list of nodes for
						each <a>node</a> <code>n</code> produced by <code>Eval(N, $this)</code> where <code>n</code> <a>conforms</a> to <code>S</code>.
					</div>
				</div>
                <p>
                    The following example returns all values of <code>ex:child</code> that conform to the given SHACL shape.
                    In order to conform to the shape, the child must have "male" as one of its values for <code>ex:gender</code>.
                </p>
<pre class="example-shapes">
[
    sh:nodes [ sh:path ex:child ] ;
    sh:filterShape [
        sh:property [
            sh:path ex:gender ;
            sh:hasValue "male" ;
        ] ;
    ] ;
]</pre>
			</section>

			<section id="node-expressions-function">
				<h3>Function Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="FunctionExpression">A <dfn data-lt="function expressions">function expression</dfn> is a <a>blank node</a>
					that does not fulfill any of the syntax rules of the other node expression types and which
					is the <a>subject</a> of exactly one <a>triple</a> <code>T</code> where the <a>object</a> is a well-formed <a>SHACL list</a>,
					and each <a>member</a> of that list is a well-formed <a>node expression</a>.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF FUNCTION EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>function expression</a> <code>$expr</code>, <code>Eval($expr, $this)</code> produces
						the list of <a>nodes</a> returned by evaluating the <a>SHACL function</a> specified as <a>predicate</a>
						of the triple <code>T</code> mentioned above.
						The arguments of the function call(s) are based on the results of the <a>node expressions</a> listed
						in the <a>object</a> list of <code>T</code> so that the first list <a>member</a> is used for the first argument, etc.
						This is done for all combinations of <a>nodes</a> produced by each <a>node expression</a>.
						If one of the <a>node expressions</a> produces the empty list and the corresponding function <a>parameter</a>
						is non-optional (see <a href="https://www.w3.org/TR/shacl/#constraint-components-parameters"><code>sh:optional</code></a>), then the result is the empty list.
					</div>
				</div>
				<p>
					As illustrated in the following example, <a>function expressions</a> are comparable to
					SPARQL BIND clauses.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[  ex:concat ( 
		[ sh:path ex:firstName ]
		" "
		[ sh:path ex:lastName ] 
	)
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
{
	$this ex:firstName ?a .
	$this ex:lastName ?b .
	BIND (ex:concat(?a, " ", ?b) AS ?result) .
}
</pre>
						</td>
					</tr>
				</table>
			</section>

			<section id="node-expressions-path">
				<h3>Path Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="PathExpression">A <dfn data-lt="path expressions">path expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> of the property <code>sh:path</code> (which are well-formed <a>property paths</a>)
					and at most one <a>value</a> for <code>sh:nodes</code> (which is a well-formed <a>node expression</a>).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF PATH EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>path expression</a> <code>$expr</code> that has the property path <code>P</code> as its
						<a>value</a> for <code>sh:path</code> and the <a>node expression</a> <code>N</code> as its <a>value</a>
						for <code>sh:nodes</code> (defaulting to the <a>focus node expression</a> if absent),
						<code>Eval($expr, $this)</code> produces the list of <a>values</a> of all nodes produced by <code>Eval(N, $this)</code>
						for the <a>property path</a> <code>P</code>.
						The order of results of these lists is undefined and they do not contain duplicates.
					</div>
				</div>
				<p>
					As illustrated in the following examples, <a>path expressions</a> are comparable to
					SPARQL basic graph patterns.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[  sh:path ex:firstName ] .

[  sh:nodes [ sh:path ex:children ] ;
   sh:path rdfs:label ;
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
{   $this ex:firstName ?result . }

{   $this ex:children ?a .
    ?a rdfs:label ?result .
}
</pre>
						</td>
					</tr>
				</table>
			</section>

			<section id="intersection">
				<h3>Intersection Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="intersection">An <dfn>intersection expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:intersection</code> which is a well-formed <a>SHACL list</a>
					with at least two <a>members</a> (which are well-formed node expressions).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF INTERSECTION EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>intersection expression</a> <code>$expr</code> that has the list <code>L</code> as its
						<a>value</a> for <code>sh:intersection</code>, <code>Eval($expr, $this)</code> produces
						the list of <a>nodes</a> that are produced by the first node expression from the list and are also
						in the result lists produced by the other <a>members</a> of <code>L</code>.
					</div>
				</div>
			</section>

			<section id="union">
				<h3>Union Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="union">A <dfn data-lt="union expressions">union expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:union</code> which is a well-formed <a>SHACL list</a>
					with at least two <a>members</a> (which are well-formed node expressions).</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF UNION EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>union expression</a> <code>$expr</code> that has the list <code>L</code> as its
						<a>value</a> for <code>sh:union</code>, <code>Eval($expr, $this)</code> produces
						the list of <a>nodes</a> that are the concatenation of the result lists produced by all of the <a>members</a> of <code>L</code>,
						preserving their original order.
					</div>
				</div>
				<p>
					As illustrated in the following example, <a>union expressions</a> are comparable to
					SPARQL UNION clauses.  Similar to SPARQL, they may produce duplicate results.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[  sh:union (
		[ sh:path ex:firstName ]
		[ sh:path ex:givenName ]
   )
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
{
	$this ex:firstName ?result . 
} UNION {
	$this ex:givenName ?result . 
}</pre>
						</td>
					</tr>
				</table>
			</section>

			<section id="minus">
				<h3>Minus Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="minus">A <dfn>minus expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:minus</code> which is a well-formed <a>node expression</a>
					and exactly one <a>value</a> for the property <code>sh:nodes</code> which is a well-formed <a>node expression</a>.
					</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF MINUS EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>minus expression</a> <code>$expr</code> that has
						the <a>node expression</a> <code>N</code> as its <a>value</a> for <code>sh:minus</code> and
						the <a>node expression</a> <code>M</code> as its <a>value</a> for <code>sh:nodes</code>,
						<code>Eval($expr, $this)</code> produces the list of <a>nodes</a> that are in <code>Eval(N, $this)</code> but not in <code>Eval(M, $this)</code>.
					</div>
				</div>
				<p>
					In the following example, <code>sh:minus</code> returns all values of the property <code>ex:children</code>
                    except those that are also values of <code>ex:sons</code>.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[
    sh:nodes [ sh:path ex:children ] ;
    sh:minus [ sh:path ex:sons ] ;
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
{
    $this ex:children ?result .
    MINUS {
        $this ex:sons ?result .
    }
}
</pre>
						</td>
					</tr>
				</table>
			</section>

			<section id="distinct">
				<h3>Distinct Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="distinct">A <dfn>distinct expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:distinct</code> which is a well-formed <a>node expression</a>.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF DISTINCT EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>distinct expression</a> <code>$expr</code> that has
						the <a>node expression</a> <code>N</code> as its <a>value</a> for <code>sh:distinct</code>,
						<code>Eval($expr, $this)</code> produces the list of <a>nodes</a> that are in <code>Eval(N, $this)</code> dropping any
						duplicate nodes.
					</div>
				</div>
				<p>
					The following example returns all values of <code>ex:customer</code> and <code>ex:client</code> but without duplicates.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[
    sh:distinct [
        sh:union (
            [ sh:path ex:customer ] ;
            [ sh:path ex:client ] ;
        )
    ]
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
SELECT DISTINCT (?c AS ?result)
WHERE {
    { $this ex:customer ?c }
    UNION
    { $this ex:client ?c }
}
</pre>
						</td>
					</tr>
				</table>
			</section>

			<section id="count">
				<h3>Count Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="count">A <dfn>count expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:count</code> which is a well-formed <a>node expression</a>.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF COUNT EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>count expression</a> <code>$expr</code> that has
						the <a>node expression</a> <code>N</code> as its <a>value</a> for <code>sh:count</code>,
						<code>Eval($expr, $this)</code> produces the list consisting of exactly one <a>literal</a> with <a>datatype</a> <code>xsd:integer</code>
						representing the size of the input list produced by <code>Eval(N, $this)</code>.
					</div>
				</div>
				<p>
					The following example returns the number of values of <code>ex:customer</code>.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[
    sh:count [ sh:path ex:customer ]
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
SELECT (COUNT(?c) AS ?result)
WHERE {
    $this ex:customer ?c .
}
</pre>
						</td>
					</tr>
				</table>
			</section>

			<section id="min">
				<h3>Min Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="min">A <dfn>min expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:min</code> which is a well-formed <a>node expression</a>.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF MIN EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>min expression</a> <code>$expr</code> that has
						the <a>node expression</a> <code>N</code> as its <a>value</a> for <code>sh:min</code>,
						<code>Eval($expr, $this)</code> produces the empty list if the input list produced by <code>Eval(N, $this)</code> is empty,
						or the list consisting of exactly one node that is the minimum input node as defined by <a href="https://www.w3.org/TR/sparql11-query/#defn_aggMin">SPARQL MIN</a>.
					</div>
				</div>
				<p>
					The following example returns the minimum of all values of <code>ex:turnOver</code> of all values of <code>ex:client</code> at the focus node.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[
    sh:min [ sh:path ( ex:client ex:turnOver ) ]
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
SELECT (MIN(?t) AS ?result)
WHERE {
    $this ex:client/ex:turnOver ?t .
}
</pre>
						</td>
					</tr>
				</table>
			</section>

			<section id="max">
				<h3>Max Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="max">A <dfn>max expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:max</code> which is a well-formed <a>node expression</a>.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF MAX EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>max expression</a> <code>$expr</code> that has
						the <a>node expression</a> <code>N</code> as its <a>value</a> for <code>sh:max</code>,
						<code>Eval($expr, $this)</code> produces the empty list if the input list produced by <code>Eval(N, $this)</code> is empty,
						or the list consisting of exactly one node that is the maximum input node as defined by <a href="https://www.w3.org/TR/sparql11-query/#defn_aggMax">SPARQL MAX</a>.
					</div>
				</div>
			</section>

			<section id="sum">
				<h3>Sum Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="sum">A <dfn>sum expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:sum</code> which is a well-formed <a>node expression</a>.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF SUM EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>sum expression</a> <code>$expr</code> that has
						the <a>node expression</a> <code>S</code> as its <a>value</a> for <code>sh:sum</code>,
						and for which the results of <code>Eval(S, $this)</code> are the nodes <code>n</code>,
						<code>Eval($expr, $this)</code> produces the list consisting of exactly one node that is the sum of all <code>n</code> as defined
						by <a href="https://www.w3.org/TR/sparql11-query/#defn_aggSum">SPARQL SUM</a>, producing the empty list of any of the nodes
						can not be summed up.
					</div>
				</div>
			</section>

			<section id="groupConcat">
				<h3>Group Concat Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="concat">A <dfn>group concat expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:groupConcat</code> which is a well-formed <a>node expression</a>.</span>
					<span data-syntax-rule="separator">A <a>group concat expression</a> can have a single value for the property <code>sh:separator</code>
					which is <a>literal</a> with <a>datatype</a> <code>xsd:string</code>.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF GROUP CONCAT EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>group concat expression</a> <code>$expr</code> that has
						the <a>node expression</a> <code>C</code> as its <a>value</a> for <code>sh:groupConcat</code>,
						<code>Eval($expr, $this)</code> produces the list consisting of exactly one <a>literal</a> with <a>datatype</a> <code>xsd:string</code>
						consisting of the string representation of the nodes from the input list produced by <code>Eval(C, $this)</code>.
						If <code>S</code> is the <a>value</a> of <code>sh:separator</code> then <code>S</code> will be inserted in between each pair of strings.
						It is up to the implementation to decide how to represent individual nodes as strings.
						For example, resources may be represented by their values of <code>rdfs:label</code> in the user's preferred language.
						However, if an individual node is a <a>literal</a> with <a>datatype</a> <code>xsd:string</code> then the lexical form of that node is used.
					</div>
				</div>
				<p>
					Tip: in order to control exactly how individual values get rendered, wrap the input node expression with a <a>function expression</a> that
					produces a string literal.
				</p>
				<p>
					The following example returns a comma-separated list of the labels of the values of <code>ex:child</code> at the focus node, ordered by their individual labels.
                    Here we assume each child has at most one label, to make the result predictable.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[
    sh:groupConcat [
        sh:path rdfs:label ;
        sh:nodes [ 
            sh:nodes [ sh:path ex:child ] ;
            sh:orderBy [ sh:path rdfs:label ] ;
        ] ;
    ] ;
    sh:separator ", " ;
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
SELECT (GROUP_CONCAT(?label; separator=", ") AS ?result)
WHERE {
    $this ex:child ?child .
    ?child rdfs:label ?label .
} ORDER BY ?label</pre>
						</td>
					</tr>
				</table>
			</section>

			<section id="orderBy">
				<h3>OrderBy Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="orderBy">An <dfn>orderBy expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:orderBy</code> which is a well-formed <a>node expression</a> and
					with exactly one value for the property <code>sh:nodes</code> which is a well-formed <a>node expression</a>.</span>
					<span data-syntax-rule="desc">An <a>orderBy expression</a> can have one <a>value</a> for the property <code>sh:desc</code> which
					is either <code>true</code> or <code>false</code>.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF ORDERBY EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>orderBy expression</a> <code>$expr</code> that has
						the <a>node expression</a> <code>N</code> as its <a>value</a> for <code>sh:nodes</code> and
						the <a>node expression</a> <code>O</code> as its <a>value</a> for <code>sh:orderBy</code>,
						<code>Eval($expr, $this)</code> produces a list consisting of exactly the results <code>n</code> of <code>Eval(N, $this)</code>
						ordered by the first node from <code>Eval(O, n)</code> according to the node comparison policy of the
						<a href="https://www.w3.org/TR/sparql11-query/#modOrderBy">SPARQL ORDER BY</a> operator.
						If <code>sh:desc</code> is <code>true</code> for the expression, then the order is descending, otherwise ascending. 
					</div>
				</div>
				<p>
					The following example returns the list of values of <code>ex:child</code> at the focus node, ordered by their individual labels.
                    Here we assume each child has at most one label, to make the result predictable.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[
    sh:nodes [ sh:path ex:child ] ;
    sh:orderBy [ sh:path rdfs:label ] ;
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
SELECT DISTINCT ?child
WHERE {
    $this ex:child ?child .
    OPTIONAL {
        ?child rdfs:label ?label .
    }
} ORDER BY ?label</pre>
						</td>
					</tr>
				</table>
			</section>

			<section id="limit">
				<h3>Limit Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="limit">A <dfn>limit expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:limit</code> which is a <a>literal</a> with <a>datatype</a> <code>xsd:integer</code> and
					with exactly one value for the property <code>sh:nodes</code> which is a well-formed <a>node expression</a>.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF LIMIT EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>limit expression</a> <code>$expr</code> that has
						the <a>node expression</a> <code>N</code> as its <a>value</a> for <code>sh:nodes</code> and
						<code>L</code> as its <a>value</a> for <code>sh:limit</code>,
						<code>Eval($expr, $this)</code> produces the list consisting of exactly the first <code>L</code> results of <code>Eval(N, $this)</code>.
					</div>
				</div>
				<p>
					The following example returns at most two values of <code>ex:parent</code> at the focus node.
				</p>
				<table style="width:100%; border-collapse: collapse;">
					<tr>
						<td style="width: 50%; padding: 0 4px 0 0">
<pre class="example-shapes" style="margin-top: 0">
[
    sh:limit 2 ;
    sh:nodes [ sh:path ex:parent ] ;
] .</pre>
						</td>
						<td style="width: 50%; padding: 0 0 0 4px">
<pre class="example-sparql" style="margin-top: 0">
SELECT ?parent
WHERE {
    $this ex:parent ?parent .
} LIMIT 2</pre>
						</td>
					</tr>
				</table>
			</section>

			<section id="offset">
				<h3>Offset Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="offset">An <dfn>offset expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:offset</code> which is a <a>literal</a> with <a>datatype</a> <code>xsd:integer</code> and
					with exactly one value for the property <code>sh:nodes</code> which is a well-formed <a>node expression</a>.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF OFFSET EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>offset expression</a> <code>$expr</code> that has
						the <a>node expression</a> <code>N</code> as its <a>value</a> for <code>sh:nodes</code> and
						<code>O</code> as its <a>value</a> for <code>sh:offset</code>,
						<code>Eval($expr, $this)</code> produces the list consisting of the results of <code>Eval(N, $this)</code> except for the first <code>O</code> ones.
					</div>
				</div>
			</section>

			<section id="ask">
				<h3>SPARQL ASK Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="ask">A <dfn>SPARQL ASK expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:ask</code> which is string literal. 
					The blank node may have <a>values</a> for the property <code>sh:prefixes</code> and these values are <a>IRIs</a> or <a>blank nodes</a>.
					Using the <a>values</a> of <code>sh:prefixes</code> as defined by
					<a href="https://www.w3.org/TR/shacl/#sparql-prefixes">5.2.1 Prefix Declarations for SPARQL Queries</a>,
					the <a>value</a> of <code>sh:ask</code> must be valid SPARQL 1.1 ASK query.
					The blank node may also have exactly one value for the property <code>sh:nodes</code> which is a well-formed <a>node expression</a>.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF SPARQL ASK EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>SPARQL ASK expression</a> <code>$expr</code> that represents the SPARQL ASK query <code>A</code>
						and that has the (optional) <a>node expression</a> <code>N</code> as its <a>value</a> for <code>sh:nodes</code>:
						If <code>N</code> is not present, then <code>Eval($expr, $this)</code> produces the list of length 1 consisting of either <code>true</code> or
						<code>false</code> based on the result of executing <code>A</code> with the node <code>$this</code> as the a pre-bound
						variable <code>$this</code>.
						If <code>N</code> is present, then <code>Eval($expr, $this)</code> produces a corresponding list of boolean literals for each node
						produced by <code>Eval(N, $this)</code> as pre-bound variable <code>$this</code>. 
					</div>
				</div>
                <p>
                    The following example produces <code>true</code> if the focus node has the given <code>rdf:type</code>.
                </p>
<pre class="example-shapes">
[
    sh:ask "ASK { $this a &lt;http://example.org/ns#Person&gt; }"
] .</pre>
            </section>

			<section id="select">
				<h3>SPARQL SELECT Expressions</h3>
				<p class="syntax">
					<span data-syntax-rule="select">A <dfn>SPARQL SELECT expression</dfn> is a <a>blank node</a>
					with exactly one <a>value</a> for the property <code>sh:select</code> which is string literal. 
					The blank node may have <a>values</a> for the property <code>sh:prefixes</code> and these values are <a>IRIs</a> or <a>blank nodes</a>.
					Using the <a>values</a> of <code>sh:prefixes</code> as defined by
					<a href="https://www.w3.org/TR/shacl/#sparql-prefixes">5.2.1 Prefix Declarations for SPARQL Queries</a>,
					the <a>value</a> of <code>sh:select</code> must be valid SPARQL 1.1 SELECT query with exactly one result variable.
					The blank node may also have exactly one value for the property <code>sh:nodes</code> which is a well-formed <a>node expression</a>.</span>
				</p>
				<div class="def def-text">
					<div class="def-header">EVALUATION OF SPARQL SELECT EXPRESSIONS</div>
					<div class="def-text-body">
						For the <a>SPARQL SELECT expression</a> <code>$expr</code> that represents the SPARQL SELECT query <code>S</code>
						and that has the (optional) <a>node expression</a> <code>N</code> as its <a>value</a> for <code>sh:nodes</code>:
						If <code>N</code> is not present, then <code>Eval($expr, $this)</code> produces the list of all bindings of the result variable produced
						by executing <code>S</code> with the node <code>$this</code> as the a pre-bound variable <code>$this</code>.
						If <code>N</code> is present, then <code>Eval($expr, $this)</code> produces a list concatenating the corresponding results when <code>S</code> is
						executed for each node produced by <code>Eval(N, $this)</code> as pre-bound variable <code>$this</code>. 
					</div>
				</div>
                <p>
                    The following example is an excerpt of a Turtle file declaring a SPARQL SELECT expression using namespace prefixes.
                </p>
<pre class="example-shapes">
&lt;http://example.org/ns&gt;
    a owl:Ontology ;
    sh:declare [
        a sh:PrefixDeclaration ;
        sh:prefix "ex" ;
        sh:namespace "http://example.org/ns#"^^xsd:anyURI ;
    ] .

[
    sh:prefixes &lt;http://example.org/ns&gt; ;
    sh:select """
        SELECT DISTINCT ?client
        WHERE {
            $this ex:client ?client .
            ?client ex:address/ex:country ?country .
            ?country ex:memberOf ex:WHO .
        }
    """ ;
] .</pre>
			</section>
		</section>
		
		<section id="ExpressionConstraintComponent">
			<h2>Expression Constraints</h2>
			<p>
				Based on <a>node expressions</a>, this section introduces a <a>constraint component</a> called
				<dfn data-lt="expression constraint">expression constraints</dfn>.
				Expression constraints can be used in any <a>shape</a> to declare the condition that the
				<a>node expression</a> specified via <code>sh:expression</code> has <code>true</code> as its (only) result.
				In the evaluation of these node expressions is repeated for all <a>value nodes</a> of the <a>shape</a>
				as the <a>focus node</a>.
			</p>
			<p>
				<span class="component-class">Constraint Component IRI</span>: <code>sh:ExpressionConstraintComponent</code>
			</p>

			<div class="parameters">Parameters:</div>
			<table class="term-table">
				<tr>
					<th>Property</th>
					<th>Summary and Syntax Rules</th>
				</tr>
				<tr>
					<td><code>sh:expression</code></td>
					<td>
						The <a>node expression</a> that must return <code>true</code>.
						<span data-syntax-rule="expression-scope">The <a>values</a> of <code>sh:expression</code> at a
						<a>shape</a> must be well-formed <a>node expressions</a>.</span>
					</td>
				</tr>
			</table>
			<div class="def def-text">
				<div class="def-header">TEXTUAL DEFINITION</div>
				<div class="def-text-body" data-validator="Filter">
					For each <a>value node</a> <code>v</code> where <code>Eval(v, $expression)</code>
					returns a node set that is not equal to <code>{ true }</code>
					there is a <a>validation result</a> that has <code>v</code> as its <code>sh:value</code>
					and <code>$expression</code> as its <code>sh:sourceConstraint</code>.
					If the <code>$expression</code> has <a>values</a> for <code>sh:message</code> in the <a>shapes graph</a>
					then these <a>values</a> become the (only) values for <code>sh:resultMessage</code> in the
					<a>validation result</a>.
				</div>
			</div>
			<p><em>The remainder of this section is informative.</em></p>
			<p>
				The following example assumes that there are <a>SHACL functions</a> <code>ex:concat</code>,
				<code>ex:strlen</code> and <code>ex:lessThan</code> and uses them to verify that the
				combined string length of <code>ex:firstName</code> and <code>ex:lastName</code> is less than 30.
			</p>
			<pre class="example-shapes">
ex:FilterExampleShape
	a sh:NodeShape ;
	sh:expression [
		ex:lessThan ( 
			[ ex:strlen ( 
				[ ex:concat ( [ sh:path ex:firstName] [ sh:path ex:lastName ] ) ] ) 
			]
			30 );
	] .</pre>
		</section>

		<section id="rules">
			<h2>SHACL Rules</h2>
			<p>
				SHACL defines an RDF vocabulary to describe <a>shapes</a> - collections of <a>constraints</a> that apply to a set of nodes.
				Shapes can be associated with nodes using a flexible <a>target</a> mechanism, e.g. for all instances of a class.
				One focus area of SHACL is data validation.
				However, the same principles of describing data patterns in shapes can also be exploited for other purposes.
				<a>SHACL rules</a> build on SHACL to form a light-weight RDF vocabulary for the exchange of <a>rules</a> that can be used
				to derive <a>inferred</a> RDF <a>triples</a> from existing <em>asserted</em> <a>triples</a>.
			</p>
			<p>
				The <a>SHACL rules</a> feature defined in this section includes a general framework using the properties
				such as <code>sh:values</code>, <code>sh:rule</code> and <code>sh:condition</code>, plus an extension mechanism for specific <a>rule types</a>.
				This document defines two such rule types: <a>Triple rules</a> and <a>SPARQL rules</a>.
				Other documents, including SHACL JavaScript Extensions [[shacl-js]], can define additional types of rules.
			</p>
			
			<section id="rules-examples" class="informative">
				<h3>Examples of SHACL Rules</h3>
				<p>
					The following example illustrates the use of a <a>triple rule</a> that adds an <code>rdf:type</code>
					<a>triple</a> so that those <a>SHACL instances</a> of <code>ex:Rectangle</code> where the
					<code>ex:width</code> equals the <code>ex:height</code> are also marked to be instances of <code>ex:Square</code>.
					The rule applies only to well-formed rectangles that <a>conform</a> to the <code>ex:Rectangle</code> <a>shape</a>,
					e.g. by having exactly one width and height, both integers.
				</p>
				<pre class="example-shapes" title="A triple rule to classify certain rectangles as squares">
ex:Rectangle
	a rdfs:Class, sh:NodeShape ;
	rdfs:label "Rectangle" ;
	sh:property [
		sh:path ex:height ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
		sh:minCount 1 ;
		sh:name "height" ;
	] ;
	sh:property [
		sh:path ex:width ;
		sh:datatype xsd:integer ;
		sh:maxCount 1 ;
		sh:minCount 1 ;
		sh:name "width" ;
	] ;
	sh:rule [
		a sh:TripleRule ;
		sh:subject sh:this ;
		sh:predicate rdf:type ;
		sh:object ex:Square ;
		sh:condition ex:Rectangle ;
		sh:condition [
			sh:property [
				sh:path ex:width ;
				sh:equals ex:height ;
			] ;
		] ;
	] .</pre>
				<pre class="example-data">
ex:InvalidRectangle
	a ex:Rectangle .

ex:NonSquareRectangle
	a ex:Rectangle ;
	ex:height 2 ;
	ex:width 3 .
	
ex:SquareRectangle
	a ex:Rectangle ;
	ex:height 4 ;
	ex:width 4 .</pre>
				<p>
					For the <a>data graph</a> above, a SHACL rules engine will produce the following inferred triples:
				</p>
				<pre class="example-inferences">	ex:SquareRectangle rdf:type ex:Square .</pre>
				<p>
					No inferences will be made for <code>ex:NonSquareRectangle</code> because its width is not equal to its height.
					No inferences will be made for <code>ex:InvalidRectangle</code> because although it has equal width
					and height (namely none), it does not pass the <code>sh:condition</code> of being a well-formed rectangle.
				</p>
				<p>
					The following example illustrates a simple use case of a <a>SPARQL rule</a> that applies to all instances of
					the class <code>ex:Rectangle</code> and computes the values of the <code>ex:area</code> property by multiplying
					the rectangle's width and height:
				</p>
				<pre class="example-shapes" title="A rule to compute the area of a Rectangle">
ex:RectangleShape
	a sh:NodeShape ;
	sh:targetClass ex:Rectangle ;
	sh:property [
		sh:path ex:width ;
		sh:datatype xsd:integer ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] ;
	sh:property [
		sh:path ex:height ;
		sh:datatype xsd:integer ;
		sh:minCount 1 ;
		sh:maxCount 1 ;
	] .

ex:RectangleRulesShape
	a sh:NodeShape ;
	sh:targetClass ex:Rectangle ;
	sh:rule [
		a sh:SPARQLRule ;
		sh:prefixes ex: ;
		sh:construct """
			CONSTRUCT {
				$this ex:area ?area .
			}
			WHERE {
				$this ex:width ?width .
				$this ex:height ?height .
				BIND (?width * ?height AS ?area) .
			}
			""" ;
		sh:condition ex:RectangleShape ;    # Rule only applies to Rectangles that conform to ex:RectangleShape
	] ;
.</pre>
				<p>
					An engine that is capable of executing such rules uses the <a>target</a> statements associated
					with the <a>shapes</a> in the <a>shapes graph</a> to determine which rules need to be executed on which target nodes.
					For those target nodes that <a>conform</a> to any <a href="#condition">condition shapes</a>, it executes the provided
					CONSTRUCT queries to produce the inferred triples.
					During the execution of the query, the variable <code>this</code> has the current <a>focus node</a> as <a>pre-bound</a> variable.
					For the following <a>data graph</a>, the <a>triples</a> below would be produced.
				</p>
				<pre class="example-data">
ex:ExampleRectangle
	a ex:Rectangle ;
	ex:width 7 ;
	ex:height 8 .

ex:InvalidRectangle    # Lacks a value for ex:height, so sh:condition is not met
	a ex:Rectangle ;
	ex:width 7 .</pre>
				<p>
					Inferred triples:
				</p>
				<pre class="example-inferences">	ex:ExampleRectangle ex:area 56 .</pre>
				<p>
					The following variation produces the same results as the <a>SPARQL rule</a>, but uses a <a>Triple rule</a>.
					While not as expressive as CONSTRUCT-based rules, <a>Triple rules</a> are more declarative and
					may be executed on platforms that do not support SPARQL.
				</p>
				<pre class="example-shapes" title="A triple rule to compute the area of a Rectangle">
ex:RectangleRulesShape
	a sh:NodeShape ;
	sh:targetClass ex:Rectangle ;
	sh:rule [
		a sh:TripleRule ;
		sh:subject sh:this ;
		sh:predicate ex:area ;    # Computes the values of the ex:area property at the focus nodes
		sh:object [
			ex:multiply ( [ sh:path ex:width ] [ sh:path ex:height ] ) ;
		] ;
		sh:condition ex:RectangleShape ;    # Rule only applies to Rectangles that conform to ex:RectangleShape
	] .</pre>
				<p id="example-property-value-rule">
					Finally, the following variation does the same inferences but using a <a>property value rule</a>.
					These rules are using a more compact syntax than triple rules and are directly attached to <a>property shapes</a>
					with the property <code>sh:values</code>.
				</p>
				<pre class="example-shapes" title="A property value rule to compute the area of a Rectangle">
ex:RectangleRulesShape
	a sh:NodeShape ;
	sh:targetClass ex:Rectangle ;
	sh:property [
		sh:path ex:area ;    # Computes the values of the ex:area property at the focus nodes
		sh:values [
			ex:multiply ( [ sh:path ex:width ] [ sh:path ex:height ] ) ;
		] ;
	] .</pre>
			</section>
	
			<section id="rules-syntax">
				<h2>General Syntax of SHACL Rules</h2>
				<p>
					The <a>values</a> of the property <code>sh:rule</code> at a <a>shape</a> are called <dfn data-lt="rule|rules|SHACL rule">SHACL rules</dfn>.
					SHACL has a flexible design in which multiple types of rules can be supported,
					including <a>Triple rules</a> and <a>SPARQL rules</a>.
					Each <dfn data-lt="rule types">rule type</dfn> is identified by an <a>IRI</a> that is used as <code>rdf:type</code> of rules.
					Each rule type also defines <dfn>execution instructions</dfn> that can be implemented by rule engines.
				</p>
				<p class="syntax">
					<span data-syntax-rule="rule-type">Each <a>SHACL rule</a> has at least one <code>rdf:type</code> which is a <a>IRI</a>.</span>
				</p>
				<p>
					Rules can have multiple types, e.g. to provide instructions that work either in SPARQL or JavaScript,
					depending on the capabilities of the engine.
					The creator of such rules needs to make sure that such rules have consistent semantics.
					Rule <code>R</code> has <a>rule type</a> <code>T</code> if <code>R</code> is a <a>SHACL instance</a> of <code>T</code>.
				</p>
				<p>
					All rules may have the properties defined in the rest of this section.
				</p>
				<section id="condition">
					<h3>sh:condition</h3>
					<p>
						A <a>rule</a> may have values for the property <code>sh:condition</code> to specify <a>shapes</a>
						that the <a>focus nodes</a> must conform to before the rule gets executed.
					</p>
					<p class="syntax">
						<span data-syntax-rule="condition-node">The <a>values</a> of <code>sh:condition</code> at a <a>rule</a> must be well-formed <a>shapes</a>.</span>
					</p>
				</section>
				<section id="rules-order">
					<h3>sh:order</h3>
					<p>
						Rules and shapes may specify its relative <dfn>execution order</dfn> as defined in this section.
					</p>
					<p class="syntax">
						<span data-syntax-rule="rule-order-maxCount">Each <a>rule</a> or <a>shape</a> may have at most one <a>value</a> for the
						property <code>sh:order</code>.</span>
						<span data-syntax-rule="rule-order-datatype">The values of <code>sh:order</code> at <a>rules</a> and <a>shapes</a>
						are <a>literals</a> with a <em>numeric</em> datatype such as <code>xsd:decimal</code>.</span>
					</p>
					<p>
						If unspecified, then the default <a>execution order</a> is <code>0</code>.
						These values are used by a <a>rules engine</a> to determine the order of <a>rules</a>.
						When the <a>rules</a> associated with a <a>shape</a> are executed, <a>rules</a> with larger values will be executed after
						those with smaller values.
					</p>
					<pre class="example-shapes" title="Rule order example">
ex:RuleOrderExampleShape
	a sh:NodeShape ;
	sh:targetClass ex:Person ;
	sh:rule [
		a sh:SPARQLRule ;
		rdfs:label "Infer uncles, i.e. male siblings of the parents of $this" ;
		sh:prefixes ex: ;
		sh:order 1 ;   # Will be evaluated before 2
		sh:construct """
			CONSTRUCT {
				$this ex:uncle ?uncle .
			}
			WHERE {
				$this ex:parent ?parent .
				?parent ex:sibling ?uncle .
				?uncle ex:gender ex:male .
			}
			"""
	] ;
	sh:rule [
		a sh:SPARQLRule ;
		rdfs:label "Infer cousins, i.e. the children of the uncles" ;
		sh:prefixes ex: ;
		sh:order 2 ;
		sh:construct """
			CONSTRUCT {
				$this ex:cousin ?cousin .
			}
			WHERE {
				$this ex:uncle ?uncle .
				?cousin ex:parent ?uncle .
			}
			"""
	] .</pre>
				</section>
				<section id="deactivated">
					<h3>sh:deactivated</h3>
					<p>
						Rules may be <em>deactivated</em> by setting <code>sh:deactivated</code> to <code>true</code>.
						Deactivated rules are ignored by the rules engine.
					</p>
					<p class="syntax">
						<span data-syntax-rule="deactivated-maxCount">Each <a>rule</a> may have at most one <a>value</a> for the
						property <code>sh:deactivated</code>.</span>
						<span data-syntax-rule="deactivated-in">The <a>values</a> of <code>sh:deactivated</code> are either
						of the <code>xsd:boolean</code> literals <code>true</code> or <code>false</code>.</span>
					</p>
				</section>
			</section>
			<section id="Rules">
				<h3>The sh:Rules Entailment Regime</h3>
				<p>
					SHACL defines the property <a href="https://www.w3.org/TR/shacl/#shacl-rdfs"><code>sh:entailment</code></a>
					to link a <a>shapes graph</a> with <em>entailment regimes</em>.
					The <a>IRI</a> <code>sh:Rules</code> represents the <dfn>SHACL rules entailment regime</dfn>.
					In the following example, the shapes graph indicates to a SHACL validation engine that the SHACL rules
					inside of the <a>shapes graph</a> need to be executed prior to starting the validation.
				</p>
				<pre class="example-shapes">
&lt;http://example.org/my-shapes&gt;
	a owl:Ontology ;
	sh:entailment sh:Rules .</pre>
				<p>
					Following the general policy for SHACL, validation engines that do <em>not</em> support the <a>SHACL rules entailment regime</a>
					MUST signal a <a>failure</a> if this <a>triple</a> is present.
					Validation engines that do support the <a>SHACL rules entailment regime</a> execute the rules following the
					<a href="#rules-execution">rules execution instructions</a> prior to performing the actual validation. 
				</p>
			</section>
			<section id="rules-execution">
				<h3>General Execution Instructions for SHACL Rules</h3>
				<p>
					A <dfn data-lt="rules engine">SHACL rules engine</dfn> is a computer procedure that takes as input
					a <a>data graph</a> and a <a>shapes graph</a> and is capable of adding <a>triples</a> to the <a>data graph</a>.
					The new <a>triples</a> that are produced by a rules engine are called the <dfn data-lt="inferring|infer">inferred</dfn> triples.
				</p>
				<p>
					Note that, from a logical perspective, the <a>data graph</a> will be <em>modified</em> if <a>triples</a> get inferred.
					This means that rules can trigger after other triples have been inferred.
					However, in cases where the original data should not be modified, implementations may construct a logical <a>data graph</a>
					that has the original data as one subgraph and a dedicated inferences graph as another subgraph, and where
					the inferred triples get added to the inferences graph only.
				</p>
				<p>
					In order to count as a SHACL rules engine, an implementation must be capable of <a>inferring</a> <a>triples</a>
					according to the following procedure (given in pseudo-code), or a different algorithm as long as the result
					is the same as specified.
					Note that this algorithm only covers a single "iteration" over all rules, without prescribing the behavior
					if the same rule needs to be applied multiple times after other rules have fired.
					The latter is left to future work.
				</p>
				<pre>
	for each <a>shape</a> <code>S</code> in the <a>shapes graph</a>, ordered by <a>execution order</a> {
		for each non-deactivated <a>rule</a> <code>R</code> in the <a>shape</a>, ordered by <a>execution order</a> {
			for each <a>target</a> node <code>T</code> of <code>S</code> that <a>conforms</a> to all <a href="#condition">conditions</a> of <code>R</code> {
				execute <code>R</code> using <code>T</code> as <a>focus node</a> following the <a>execution instructions</a> of its <a>rule types</a>
			}
		}
	}</pre>
				<p>
					The <a>triples</a> that are inferred by a <a>rule</a> do not <em>immediately</em> become part of the <a>data graph</a>,
					i.e. the <a>triples</a> produced by one <a>rule</a> can not always be queried by other <a>rules</a>.
					These policies reduce the likelihood of race conditions and better support parallel execution.
				</p>
				<ul>
					<li>
						If two <a>shapes</a> have the same <a>execution order</a> then their newly inferred <a>triples</a> are
						not visible to each other.
					</li>
					<li>
						If two <a>rules</a> have the same <a>execution order</a> then their newly inferred <a>triples</a> are
						not visible to each other.
					</li>
					<li>
						If the same <a>rule</a> is executed on multiple target nodes then the newly inferred <a>triples</a> are
						not visible to the other target nodes.
					</li>
				</ul>
				<p>
					If a <a>rules engine</a> is not able to execute a given <a>rule</a>
					because it does not support any of the <a>rule types</a> of the <a>rule</a>,
					then it reports a <a>failure</a>.
				</p>
				<p>
					At no time are inferred triples visible to the <a>shapes graph</a>, i.e. it is impossible for rules
					to modify the definitions of rules or shapes.
				</p>
			</section>

			<section id="TripleRule">
				<h3>Triple Rules</h3>
				<p>
					This section defines a <a>rule type</a> called <dfn data-lt="triple rule">triple rules</dfn>, identified by
					the <a>IRI</a> <code>sh:TripleRule</code>.
					<a>Triple rules</a> have the following properties:
				<p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Summary and Syntax Rules</th>
					</tr>
					<tr>
						<td><code>sh:subject</code></td>
						<td>
							The <a>node expression</a> used to compute the <a>subjects</a> of the <a>triples</a>.
							<span data-syntax-rule="TripleRule-subject">Each <a>triple rule</a> must have exactly one
							<a>value</a> of the property <code>sh:subject</code> (which must be a well-formed <a>node expression</a>).
							</span>
						</td>
					</tr>
					<tr>
						<td><code>sh:predicate</code></td>
						<td>
							The <a>node expression</a> used to compute the <a>predicates</a> of the <a>triples</a>.
							<span data-syntax-rule="TripleRule-predicate">Each <a>triple rule</a> must have exactly one
							<a>value</a> of the property <code>sh:predicate</code> (which must be a well-formed <a>node expression</a>).
							</span>
						</td>
					</tr>
					<tr>
						<td><code>sh:object</code></td>
						<td>
							The <a>node expression</a> used to compute the <a>objects</a> of the <a>triples</a>.
							<span data-syntax-rule="TripleRule-object">Each <a>triple rule</a> must have exactly one
							<a>value</a> of the property <code>sh:object</code> (which must be a well-formed <a>node expression</a>).
							</span>
						</td>
					</tr>
				</table>
				<div class="def def-text">
					<div class="def-header">EXECUTION OF TRIPLE RULES</div>
					<div class="def-text-body">
						Let <code>S</code>, <code>P</code> and <code>O</code> be the sets of <a>nodes</a> produced by evaluating
						the <a>node expressions</a> that are the values of <code>sh:subject</code>, <code>sh:predicate</code>
						and <code>sh:object</code> respectively at the <a>triple rule</a>.
						For each combination of members <code>s</code> of <code>S</code>, <code>p</code> of <code>P</code> and
						<code>o</code> of <code>O</code>, <a>infer</a> a <a>triple</a> with <a>subject</a> <code>s</code>,
						<a>predicate</a> <code>p</code> and <a>object</a> <code>o</code>.
					</div>
				</div>

				<section id="PropertyValueRule">
					<h4>Property Value Rules</h4>
					<p>
						<a>Property value rules</a> provide syntactic sugar for <a>triple rules</a>, supporting the use case where
						triple rules are used to infer values of a single property at a single focus node.
					</p>
					<p>
						A <dfn data-lt="property value rules">property value rule</dfn> is represented by a <a>value</a> <code>V</code> of the property
						<code>sh:values</code> of a <a>property shape</a> <code>P</code> that has a <a>IRI</a> <code>path</code> as its value for <code>sh:path</code>.
						<span data-syntax-rule="values">The <a>values</a> of the property <code>sh:values</code> must be well-formed <a>node expressions</a>.</span>
						For each node shape <code>N</code> that has <code>P</code> as <a>value</a> of <code>sh:property</code>, there is an implicit <a>triple rule</a> <code>T</code>
						equivalent to the following triples (unless either <code>P</code> or <code>N</code> have <code>true</code> as the <a>value</a> of <code>sh:deactivated</code>):
					</p>
					<ul>
						<li><code>N sh:rule T</code></li>
						<li><code>T rdf:type sh:TripleRule</code></li>
						<li><code>T sh:subject sh:this</code></li>
						<li><code>T sh:predicate path</code></li>
						<li><code>T sh:object V</code></li>
					</ul>
					<p>
						An <a href="#example-property-value-rule">example</a> property value rule had already been provided.
					</p>
				</section>
			</section>
			
			<section id="SPARQLRule">
				<h3>SPARQL Rules</h3>
				<p>
					This section defines a <a>rule type</a> called <dfn data-lt="SPARQL rule">SPARQL rules</dfn>,
					identified by the <a>IRI</a> <code>sh:SPARQLRule</code>.
					<a>SPARQL rules</a> have the following properties:
				<p>
				<table class="term-table">
					<tr>
						<th>Property</th>
						<th>Summary and Syntax Rules</th>
					</tr>
					<tr>
						<td><code>sh:construct</code></td>
						<td>
							The SPARQL CONSTRUCT query.
							<span data-syntax-rule="construct-count"><a>SPARQL rules</a> must have exactly one
							<a>value</a> for the property <code>sh:construct</code>.</span>
							<span data-syntax-rule="construct-datatype">The values of <code>sh:construct</code>
							are <a>literals</a> with datatype <code>xsd:string</code>.</span>
						</td>
					</tr>
					<tr>
						<td><code>sh:prefixes</code></td>
						<td>
							The prefixes to use to turn the <code>sh:construct</code> into a SPARQL query.
							<a>SPARQL rules</a> may use the property <code>sh:prefixes</code> to declare a dependency on prefixes based on the
							mechanism defined in <a href="https://www.w3.org/TR/shacl/#sparql-prefixes">Prefix Declarations for SPARQL Queries</a>
							from the SHACL specification [[!shacl]].
							This mechanism allows users to abbreviate URIs in the <code>sh:construct</code> strings.
						</td>
					</tr>
				</table>
				<div class="def def-text">
					<div class="def-header">EXECUTION OF SPARQL RULES</div>
					<div class="def-text-body">
						Let <code>Q</code> be the SPARQL CONSTRUCT query derived from the values of the properties
						<code>sh:construct</code> and <code>sh:prefixes</code> of the <a>SPARQL rule</a> in the <a>shapes graph</a>.
						For each <a>focus node</a>, execute the query <code>Q</code>
						<a>pre-binding</a> the variable <code>this</code> to the <a>focus node</a>,
						and <a>infer</a> the constructed <a>triples</a>.
					</div>
				</div>
			</section>
		</section>
		
		<section id="syntax-rules" class="appendix">
			<h2>Summary of Syntax Rules from this Document</h2>
			<p>
				This section enumerates all normative syntax rules from this document.
				This section is automatically generated from other parts of this spec and hyperlinks are provided back
				into the prose if the context of the rule in unclear. 
				Nodes that violate these rules in a shapes graph are ill-formed.
			</p>
			<table class="term-table" id="syntax-rules-table">
				<tr>
					<th>Syntax Rule Id</th>
					<th>Syntax Rule Text</th>
				</tr>
			</table>
		</section>
						
		<section id="security" class="appendix informative">
			<h2>Security and Privacy Considerations</h2>
			<p>
				The features defined in this document share certain security and privacy considerations with those
				<a href="https://www.w3.org/TR/shacl/#security">mentioned</a> in [[!shacl]].
				The general advice is for users to only use trusted and controlled shape graphs.
			</p>
		</section>
		
		<section id="ack" class="appendix informative">
			<h2>Acknowledgements</h2>
			<p>
				Many people contributed to this document, including members of the RDF Data Shapes Working Group.
				The sections <a href="#targets"></a>, <a href="#sparql-constraints-annotations"></a> and
				<a href="#functions"></a> had been part of earlier drafts of the main SHACL specification [[!shacl]]
				but were moved out in part due to time constraints in the Working Group.
				Dimitris Kontokostas was the main contributor to the <a href="#sparql-constraints-annotations"></a> section.
			</p>
		</section>
	</body>
</html>
