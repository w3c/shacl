/* converted on Fri Mar 22, 2024, 10:24 (UTC+02) by xtext-to-w3c v0.68-SNAPSHOT which is Copyright (c) 2011-2024 by Gunther Rademacher <grd@gmx.net> */

ShaclDoc ::= 'LIBRARY' IRIREF ( 'VERSION' IRIREF )? Directive* ( NodeShape | ShapeClass | PropertyShape | RuleShape | TargetShape | FunctionShape )*
Directive
         ::= BaseDecl
           | ImportsDecl
           | PrefixDecl
BaseDecl ::= 'BASE' IRIREF
ImportsDecl
         ::= 'IMPORTS' IRIREF
PrefixDecl
         ::= 'PREFIX' PNAME_NS IRIREF
ShapeClass
         ::= 'shapeClass' Iri ( '.' | '{' NodeShapeBody '}' )
NodeShape
         ::= 'shape' Iri Target* ( '.' | '{' NodeShapeBody '}' )
PropertyShape
         ::= 'property' Iri ( '.' | '{' PropertyShapeBody '}' )
RuleShape
         ::= 'rule' Iri ( '.' | '{' RuleBody '}' )
TargetShape
         ::= 'target' Iri ( '.' | TargetDeclaration '{' TargetBody '}' )
FunctionShape
         ::= 'function' Iri ( '.' | FunctionDeclaration '{' FunctionBody '}' )
Target   ::= TargetClasses
           | TargetNodes
           | TargetTargets
           | TargetSubjectsOf
           | TargetObjectsOf
           | TargetSelect
TargetClasses
         ::= '->' Iri ( ',' Iri )*
TargetSubjectsOf
         ::= '*->' Iri ( ',' Iri )*
TargetObjectsOf
         ::= '->*' Iri ( ',' Iri )*
TargetSelect
         ::= '->' SelectQuery
TargetNodes
         ::= '->' Array
TargetTargets
         ::= '->' TargetCall ( ',' TargetCall )*
TargetCall
         ::= TargetRef ParameterAssignments?
RuleBody ::= ConstructQuery ( 'if' NodeShapeOrRef )? ( 'priority' INTEGER )?
TargetBody
         ::= ( 'label' Str )? SelectQuery
TargetDeclaration
         ::= '(' ParameterDeclaration ( ',' ParameterDeclaration )* ')'
FunctionDeclaration
         ::= '(' ParameterDeclaration ( ',' ParameterDeclaration )* ')' ( 'returns' Iri )?
FunctionBody
         ::= SelectQuery
ParameterDeclaration
         ::= 'optional'? 'parameter'? Iri NodeKind? Iri? ( 'order' INTEGER )?
ParameterAssignment
         ::= Iri IriOrLiteral
ParameterAssignments
         ::= '(' ParameterAssignment ( ',' ParameterAssignment )* ')'
SparqlConstraint
         ::= SelectQuery
           | AskQuery
SelectQuery
         ::= SelectClause DatasetClause* WhereClause SolutionModifier
DescribeQuery
         ::= SKW_DESCRIBE ( VarOrIri+ | '*' ) DatasetClause* WhereClause SolutionModifier
SelectClause
         ::= SKW_SELECT ( SKW_DISTINCT | SKW_REDUCED )? ( SelectItem+ | '*' )
SelectItem
         ::= Variable
           | '(' Expression SKW_AS Variable ')'
AskQuery ::= SKW_ASK DatasetClause* WhereClause
DatasetClause
         ::= SKW_FROM SKW_NAMED? IRIREF
WhereClause
         ::= SKW_WHERE? GroupGraphPattern
SolutionModifier
         ::= GroupClause? HavingClause? OrderClause? ( LimitClause OffsetClause? | OffsetClause LimitClause? )?
ConstructQuery
         ::= SKW_CONSTRUCT ConstructTemplate DatasetClause* WhereClause SolutionModifier
ConstructTemplate
         ::= '{' TriplesSameSubject ( '.' TriplesSameSubject? )* '}'
TriplesSameSubject
         ::= VarOrTerm PropertyListNotEmpty
           | TriplesNode PropertyList
TriplesSameSubjectPath
         ::= VarOrTerm PropertyListPathNotEmpty
           | TriplesNodePath PropertyListPath
OrderClause
         ::= SKW_ORDER SKW_BY OrderCondition+
OrderCondition
         ::= ( SKW_ASC | SKW_DESC ) BrackettedExpression
           | Constraint
           | Variable
ValuesClause
         ::= ( SKW_VALUES DataBlock )?
DataBlock
         ::= DataBlockOneVar
           | DataBlockFull
DataBlockOneVar
         ::= Variable '{' DataBlockValue* '}'
DataBlockFull
         ::= '(' Variable* ')' '{' DataBlockValues* '}'
DataBlockValue
         ::= Iri
           | Literal
           | 'UNDEF'
DataBlockValues
         ::= '(' DataBlockValue* ')'
GroupClause
         ::= SKW_GROUP SKW_BY GroupCondition+
GroupCondition
         ::= BuiltInCall
           | FunctionCall
           | '(' Expression ( SKW_AS Variable )? ')'
           | Variable
HavingClause
         ::= SKW_HAVING HavingCondition
HavingCondition
         ::= Constraint
Constraint
         ::= BrackettedExpression
           | BuiltInCall
           | FunctionCall
GroupGraphPattern
         ::= '{' ( SubSelect | TriplesBlock? GraphPatternPart* ) '}'
GraphPatternPart
         ::= GraphPatternNotTriples '.'? TriplesBlock?
SubSelect
         ::= SelectClause WhereClause SolutionModifier ValuesClause
GraphPatternNotTriples
         ::= UnionGraphPattern
           | OptionalGraphPattern
           | MinusGraphPattern
           | GraphGraphPattern
           | Filter
           | Bind
           | InlineData
Bind     ::= SKW_BIND '(' Expression SKW_AS Variable ')'
InlineData
         ::= SKW_VALUES DataBlock
MinusGraphPattern
         ::= SKW_MINUS GroupGraphPattern
OptionalGraphPattern
         ::= SKW_OPTIONAL GroupGraphPattern
GraphGraphPattern
         ::= SKW_GRAPH VarOrIri GroupGraphPattern
UnionGraphPattern
         ::= GroupGraphPattern ( SKW_UNION GroupGraphPattern )*
ServiceGraphPattern
         ::= SKW_SERVICE SKW_SILENT? VarOrIri GroupGraphPattern
TriplesBlock
         ::= TriplesSameSubjectPath ( '.' TriplesSameSubjectPath? )*
Filter   ::= SKW_FILTER Constraint
PropertyListPathNotEmpty
         ::= PathObjectListPath ( ';' PathObjectList? )*
PathOrVariable
         ::= Path
           | Variable
PropertyListPath
         ::= PropertyListPathNotEmpty?
PathObjectList
         ::= PathOrVariable ObjectList
PathObjectListPath
         ::= PathOrVariable ObjectListPath
PropertyListNotEmpty
         ::= VerbObjectList ( ';' VerbObjectList? )*
PropertyList
         ::= PropertyListNotEmpty?
VerbObjectList
         ::= Verb ObjectList
Verb     ::= VarOrIri
           | 'a'
ObjectList
         ::= Object ( ',' Object )*
ObjectListPath
         ::= ObjectPath ( ',' ObjectPath )*
Object   ::= GraphNode
ObjectPath
         ::= GraphNodePath
Collection
         ::= '(' GraphNode+ ')'
CollectionPath
         ::= '(' GraphNodePath+ ')'
GraphNode
         ::= VarOrTerm
           | TriplesNode
GraphNodePath
         ::= VarOrTerm
           | TriplesNodePath
TriplesNode
         ::= Collection
           | BlankNodePropertyList
TriplesNodePath
         ::= CollectionPath
           | BlankNodePropertyListPath
BlankNodePropertyList
         ::= '[' PropertyListNotEmpty ']'
BlankNodePropertyListPath
         ::= '[' PropertyListPathNotEmpty ']'
VarOrTerm
         ::= Variable
           | GraphTerm
GraphTerm
         ::= Iri
           | RdfLiteral
           | NumericLiteral
           | BooleanLiteral
           | BlankNode
           | '(' ')'
BuiltInCall
         ::= ( ( ( FN_STR | FN_LANG | FN_DATATYPE | FN_IRI | FN_URI | FN_RAND | FN_CEIL | FN_FLOOR | FN_ROUND | FN_STRLEN | FN_UCASE | FN_LCASE | FN_ENCODE_FOR_URI | FN_YEAR | FN_MONTH | FN_DAY | FN_HOURS | FN_MINUTES | FN_SECONDS | FN_TIMEZONE | FN_TZ | FN_MD5 | FN_SHA1 | FN_SHA256 | FN_SHA384 | FN_SHA512 | 'isIRI' | FN_ISURI | FN_ISBLANK | FN_ISLITERAL ) '(' | ( ( FN_LANGMATCHES | FN_CONTAINS | FN_STRSTARTS | FN_STRENDS | FN_STRBEFORE | FN_STRAFTER | FN_STRLANG | FN_STRDT | FN_SAMETERM ) '(' | FN_IF '(' Expression ',' | ( ( FN_SUBSTR | FN_REGEXP ) '(' | FN_REPLACE '(' Expression ',' ) ( Expression ',' )? ) Expression ',' | ( FN_CONCAT | FN_COALESCE ) '(' ( Expression ',' )* ) Expression | FN_BOUND '(' Variable | FN_BNODE '(' Expression? | ( FN_NOW | FN_UUID | FN_STRUUID ) '(' ) ')'
           | ExistsFunc
           | NotExistsFunc
           | Aggregate
ExistsFunc
         ::= SKW_EXISTS GroupGraphPattern
NotExistsFunc
         ::= SKW_NOT SKW_EXISTS GroupGraphPattern
Aggregate
         ::= ( FN_COUNT '(' SKW_DISTINCT? ( '*' | Expression ) | ( FN_SUM | FN_MIN | FN_MAX | FN_SAMPLE | FN_AVG ) '(' SKW_DISTINCT? Expression | FN_GROUP_CONCAT '(' SKW_DISTINCT? Expression ( ';' FN_SEPARATOR '=' Str )? ) ')'
Expression
         ::= ConditionalOrExpression
ConditionalOrExpression
         ::= ConditionalAndExpression ( '||' ConditionalAndExpression )*
ConditionalAndExpression
         ::= ValueLogical ( '&&' ValueLogical )*
ValueLogical
         ::= RelationalExpression
RelationalExpression
         ::= NumericExpression ( ( '=' | '!=' | '<' | '>' | '<=' | '>=' ) NumericExpression | SKW_NOT? SKW_IN ExpressionList )?
ExpressionList
         ::= '(' Expression? ( ',' Expression )* ')'
NumericExpression
         ::= AdditiveExpression
AdditiveExpression
         ::= MultiplicativeExpression AdditiveTerm*
AdditiveTerm
         ::= ( '+' | '-' ) MultiplicativeExpression
           | NumericLiteral MultiplicativeTerm*
MultiplicativeExpression
         ::= UnaryExpression MultiplicativeTerm*
MultiplicativeTerm
         ::= ( '*' | '/' ) UnaryExpression
UnaryExpression
         ::= ( '!' | '+' | '-' )? PrimaryExpression
PrimaryExpression
         ::= BrackettedExpression
           | BuiltInCall
           | IriOrFunction
           | Literal
           | Variable
BrackettedExpression
         ::= '(' Expression ')'
IriOrFunction
         ::= Iri ArgList?
FunctionCall
         ::= Iri ArgList
ArgList  ::= '(' SKW_DISTINCT? Expression? ( ',' Expression )* ')'
VarOrIri ::= Variable
           | Iri
LimitClause
         ::= SKW_LIMIT INTEGER
OffsetClause
         ::= SKW_OFFSET INTEGER
RuleBodyOrRef
         ::= '{' RuleBody '}'
           | RuleRef
NodeConstraint
         ::= TypeConstraint
           | HasValueConstraint
           | InConstraint
           | MinExclusiveConstraint
           | MinInclusiveConstraint
           | MaxExclusiveConstraint
           | MaxInclusiveConstraint
           | MinLengthConstraint
           | MaxLengthConstraint
           | PatternConstraint
           | LessThanConstraint
           | LessThanOrEqualConstraint
           | NameAnnotation
           | DescriptionAnnotation
PropertyConstraint
         ::= HasValueConstraint
           | InConstraint
           | MinExclusiveConstraint
           | MinInclusiveConstraint
           | MaxExclusiveConstraint
           | MaxInclusiveConstraint
           | MinLengthConstraint
           | MaxLengthConstraint
           | PatternConstraint
           | LessThanConstraint
           | LessThanOrEqualConstraint
           | NameAnnotation
           | DescriptionAnnotation
           | DefaultValueAnnotation
PropertyCount
         ::= '[' PropertyMinCount '..' PropertyMaxCount ']'
PropertyMinCount
         ::= INTEGER
PropertyMaxCount
         ::= INTEGER
           | '*'
NodeKind ::= 'BlankNode'
           | 'IRI'
           | 'Literal'
           | 'BlankNodeOrIRI'
           | 'BlankNodeOrLiteral'
           | 'IRIOrLiteral'
PropertyShapeOrRef
         ::= ShapeRef
           | '{' PropertyShapeBody '}'
PropertyShapeBody
         ::= 'path'? Path PropertyExpression
PropertyExpression
         ::= PropertyOr
PropertyOr
         ::= PropertyXOne ( KW_OR PropertyXOne )*
PropertyXOne
         ::= PropertyAnd ( KW_XONE PropertyAnd )*
PropertyAnd
         ::= PropertyNot ( KW_AND? PropertyNot )*
PropertyNot
         ::= KW_NOT? PropertyAtom
PropertyBracketted
         ::= '(' PropertyExpression ')'
PropertyAtom
         ::= PropertyBracketted
           | Iri
           | NodeKind
           | PropertyCount
           | ( 'qualified' PropertyCount )? 'shape'? NodeShapeOrRef
           | 'property' PropertyShapeOrRef
           | PropertyConstraint
           | ( 'message' | 'severity' ) Str
           | 'closed'
           | 'deactivated'
NodeShapeOrRef
         ::= ShapeRef
           | '{' NodeShapeBody '}'
NodeShapeBody
         ::= NodeExpression
NodeExpression
         ::= NodeOr
NodeOr   ::= NodeXOne ( KW_OR NodeXOne )*
NodeXOne ::= NodeAnd ( KW_XONE NodeAnd )*
NodeAnd  ::= NodeNot ( ( KW_AND | '.' ) NodeNot )*
NodeNot  ::= KW_NOT? NodeAtom
NodeBracketted
         ::= '(' NodeExpression ')'
NodeAtom ::= NodeBracketted
           | ( 'property' | 'shape' )? ShapeRef
           | PropertyShapeBody
           | 'rule' RuleBodyOrRef
           | NodeConstraint
           | NodeKind
           | SparqlConstraint
           | ( 'message' | 'severity' ) Str
           | 'closed'
           | 'deactivated'
NameAnnotation
         ::= 'name' '=' RdfLiteral
DescriptionAnnotation
         ::= 'description' '=' RdfLiteral
DefaultValueAnnotation
         ::= 'defaultValue' '=' IriOrLiteral
TypeConstraint
         ::= ( 'class' | 'type' ) Iri
InConstraint
         ::= 'in' '=' Array
HasValueConstraint
         ::= 'hasValue' '=' IriOrLiteral
MinExclusiveConstraint
         ::= 'minExclusive' '=' NumericLiteral
MinInclusiveConstraint
         ::= 'minInclusive' '=' NumericLiteral
MaxExclusiveConstraint
         ::= 'maxExclusive' '=' NumericLiteral
MaxInclusiveConstraint
         ::= 'maxInclusive' '=' NumericLiteral
MinLengthConstraint
         ::= 'minLength' '=' NumericLiteral
MaxLengthConstraint
         ::= 'maxLength' '=' NumericLiteral
PatternConstraint
         ::= 'pattern' '=' Str
LessThanConstraint
         ::= '<' Iri
LessThanOrEqualConstraint
         ::= '<=' Iri
FN_STR   ::= 'STR'
           | 'str'
FN_LANG  ::= 'LANG'
           | 'lang'
FN_LANGMATCHES
         ::= 'LANGMATCHES'
           | 'langmatches'
FN_DATATYPE
         ::= 'DATATYPE'
           | 'datatype'
FN_BOUND ::= 'BOUND'
           | 'bound'
FN_IRI   ::= 'IRI'
           | 'iri'
FN_URI   ::= 'URI'
           | 'uri'
FN_BNODE ::= 'BNODE'
           | 'bnode'
FN_RAND  ::= 'RAND'
           | 'rand'
FN_CEIL  ::= 'CEIL'
           | 'ceil'
FN_FLOOR ::= 'FLOOR'
           | 'floor'
FN_ROUND ::= 'ROUND'
           | 'round'
FN_CONCAT
         ::= 'CONCAT'
           | 'concat'
FN_SUBSTR
         ::= 'SUBSTR'
           | 'substr'
FN_STRLEN
         ::= 'STRLEN'
           | 'strlen'
FN_REPLACE
         ::= 'REPLACE'
           | 'replace'
FN_UCASE ::= 'UCASE'
           | 'ucase'
FN_LCASE ::= 'LCASE'
           | 'lcase'
FN_ENCODE_FOR_URI
         ::= 'ENCODE_FOR_URI'
           | 'encode_for_uri'
FN_CONTAINS
         ::= 'CONTAINS'
           | 'contains'
FN_STRSTARTS
         ::= 'STRSTARTS'
           | 'strstarts'
FN_STRENDS
         ::= 'STRENDS'
           | 'strends'
FN_STRBEFORE
         ::= 'STRBEFORE'
           | 'strbefore'
FN_STRAFTER
         ::= 'STRAFTER'
           | 'strafter'
FN_YEAR  ::= 'YEAR'
           | 'year'
FN_MONTH ::= 'MONTH'
           | 'month'
FN_DAY   ::= 'DAY'
           | 'day'
FN_HOURS ::= 'HOURS'
           | 'hours'
FN_MINUTES
         ::= 'MINUTES'
           | 'minutes'
FN_SECONDS
         ::= 'SECONDS'
           | 'seconds'
FN_TIMEZONE
         ::= 'TIMEZONE'
           | 'timezone'
FN_TZ    ::= 'TZ'
           | 'tz'
FN_NOW   ::= 'NOW'
           | 'now'
FN_UUID  ::= 'UUID'
           | 'uuid'
FN_STRUUID
         ::= 'STRUUID'
           | 'struuid'
FN_MD5   ::= 'MD5'
           | 'md5'
FN_SHA1  ::= 'SHA1'
           | 'sha1'
FN_SHA256
         ::= 'SHA256'
           | 'sha256'
FN_SHA384
         ::= 'SHA384'
           | 'sha384'
FN_SHA512
         ::= 'SHA512'
           | 'sha512'
FN_COALESCE
         ::= 'COALESCE'
           | 'coalesce'
FN_IF    ::= 'IF'
           | 'if'
FN_STRLANG
         ::= 'STRLANG'
           | 'strlang'
FN_STRDT ::= 'STRDT'
           | 'strdt'
FN_SAMETERM
         ::= 'sameTerm'
           | 'SAMETERM'
           | 'sameterm'
FN_ISURI ::= 'isURI'
           | 'ISURI'
           | 'isuri'
FN_ISBLANK
         ::= 'isBLANK'
           | 'ISBLANK'
           | 'isblank'
FN_ISLITERAL
         ::= 'isLITERAL'
           | 'ISLITERAL'
           | 'isliteral'
FN_REGEXP
         ::= 'REGEX'
           | 'regexp'
FN_COUNT ::= 'COUNT'
           | 'count'
FN_AVG   ::= 'AVG'
           | 'avg'
FN_MIN   ::= 'MIN'
           | 'min'
FN_MAX   ::= 'MAX'
           | 'max'
FN_GROUP_CONCAT
         ::= 'GROUP_CONCAT'
           | 'group_concat'
FN_SEPARATOR
         ::= 'SEPARATOR'
           | 'separator'
FN_SUM   ::= 'SUM'
           | 'sum'
FN_SAMPLE
         ::= 'SAMPLE'
           | 'sample'
SKW_ASK  ::= 'ASK'
           | 'ask'
SKW_SELECT
         ::= 'SELECT'
           | 'select'
SKW_GRAPH
         ::= 'GRAPH'
           | 'graph'
SKW_OPTIONAL
         ::= 'OPTIONAL'
           | 'optional'
SKW_GROUP
         ::= 'GROUP'
           | 'group'
SKW_BIND ::= 'BIND'
           | 'bind'
SKW_HAVING
         ::= 'HAVING'
           | 'having'
SKW_AS   ::= 'AS'
           | 'as'
SKW_ORDER
         ::= 'ORDER'
           | 'order'
SKW_UNION
         ::= 'UNION'
           | 'union'
SKW_MINUS
         ::= 'MINUS'
           | 'minus'
SKW_VALUES
         ::= 'VALUES'
           | 'values'
SKW_NAMED
         ::= 'NAMED'
           | 'named'
SKW_FROM ::= 'FROM'
           | 'from'
SKW_BY   ::= 'BY'
           | 'by'
SKW_LIMIT
         ::= 'LIMIT'
           | 'limit'
SKW_FILTER
         ::= 'FILTER'
           | 'filter'
SKW_ASC  ::= 'ASC'
           | 'asc'
SKW_DESC ::= 'DESC'
           | 'desc'
SKW_EXISTS
         ::= 'EXISTS'
           | 'exists'
SKW_OFFSET
         ::= 'OFFSET'
           | 'offset'
SKW_DISTINCT
         ::= 'DISTINCT'
           | 'distinct'
SKW_REDUCED
         ::= 'REDUCED'
           | 'reduced'
SKW_CONSTRUCT
         ::= 'CONSTRUCT'
           | 'construct'
SKW_WHERE
         ::= 'WHERE'
           | 'where'
SKW_DESCRIBE
         ::= 'DESCRIBE'
           | 'describe'
SKW_NOT  ::= 'NOT'
           | 'not'
SKW_IN   ::= 'IN'
           | 'in'
SKW_SERVICE
         ::= 'SERVICE'
           | 'service'
SKW_SILENT
         ::= 'SILENT'
           | 'silent'
ShapeRef ::= AT_PNAME_LN
           | AT_PNAME_NS
           | AT_IRIREF
RuleRef  ::= AT_PNAME_LN
           | AT_PNAME_NS
           | AT_IRIREF
TargetRef
         ::= AT_PNAME_LN
           | AT_PNAME_NS
           | AT_IRIREF
FunctionRef
         ::= AT_PNAME_LN
           | AT_PNAME_NS
           | AT_IRIREF
Path     ::= PathAlternative
PathAlternative
         ::= PathSequence ( '|' PathSequence )*
PathSequence
         ::= PathEltOrInverse ( '/' PathEltOrInverse )*
PathElt  ::= PathPrimary PathMod?
PathEltOrInverse
         ::= '^'? PathElt
PathMod  ::= '?'
           | '*'
           | '+'
PathPrimary
         ::= Iri
           | 'a'
           | '!' PathNegatedPropertySet
           | '(' Path ')'
PathNegatedPropertySet
         ::= PathOneInPropertySet
           | '(' ( PathOneInPropertySet ( '|' PathOneInPropertySet )* )? ')'
PathOneInPropertySet
         ::= '^'? ( Iri | 'a' )
IriOrLiteralOrArray
         ::= IriOrLiteral
           | Array
IriOrLiteral
         ::= Iri
           | Literal
Iri      ::= IRIREF
           | PrefixedName
           | PrefixedLabel
PrefixedName
         ::= PNAME_LN
           | PNAME_NS
PrefixedLabel
         ::= LABEL_REF1
           | LABEL_REF2
BlankNode
         ::= BLANK_NODE_LABEL
           | '[' ']'
Literal  ::= RdfLiteral
           | NumericLiteral
           | BooleanLiteral
BooleanLiteral
         ::= 'true'
           | 'false'
NumericLiteral
         ::= INTEGER
           | DECIMAL
           | DOUBLE
RdfLiteral
         ::= Str ( LANGTAG | DTYPETAG )?
Str      ::= STRING_LITERAL_LONG1
           | STRING_LITERAL_LONG2
           | STRING_LITERAL1
           | STRING_LITERAL2
Array    ::= '[' IriOrLiteral* ']'
Variable ::= VAR1
           | VAR2
KW_AND   ::= 'and'
           | OP_AND
KW_OR    ::= 'or'
           | OP_OR
KW_XONE  ::= 'xone'
           | 'xor'
           | OP_XONE
KW_NOT   ::= 'not'
           | OP_NOT

<?TOKENS?>

OP_AND   ::= [&#x2227]
OP_OR    ::= [|#x2228]
OP_NOT   ::= [!#xAC]
OP_XONE  ::= '><'
           | [#x22BB#x2A52]
VAR1     ::= '?' VARNAME
VAR2     ::= '$' VARNAME
VARNAME  ::= ( PN_CHARS_U | DIGIT ) ( PN_CHARS_U | DIGIT | [#xB7#x300-#x36F#x203F-#x2040] )*
PASS     ::= [ #x9#xD#xA]+
COMMENT  ::= '#' [^#xD#xA]*
IRIREF   ::= '<' ( [^<>"{}|^`\#x0-#x20#xAB#xBB] | UCHAR )* '>'
LABEL_REF1
         ::= #xAB ( .* - ( .* #xBB .* ) ) #xBB
LABEL_REF2
         ::= '<<' ( .* - ( .* '>>' .* ) ) '>>'
PNAME_NS ::= PN_PREFIX? ':'
PNAME_LN ::= PNAME_NS PN_LOCAL
AT_PNAME_NS
         ::= AT PN_PREFIX? ':'
AT_PNAME_LN
         ::= AT PNAME_NS PN_LOCAL
AT_IRIREF
         ::= AT IRIREF
DTYPETAG ::= '^^' ( PNAME_NS PN_LOCAL | IRIREF )
BLANK_NODE_LABEL
         ::= '_:' ( PN_CHARS_U | [0-9] ) ( ( PN_CHARS | '.' )* PN_CHARS )?
LANGTAG  ::= AT [A-Za-z]+ ( '-' [A-Za-z0-9]+ )*
INTEGER  ::= [+#x2D]? DIGIT+
DECIMAL  ::= [+#x2D]? DIGIT* '.' DIGIT+
DOUBLE   ::= [+#x2D]? ( DIGIT+ '.' | '.'? DIGIT ) DIGIT* EXPONENT
UCASE_LABEL
         ::= [A-Z_] ( [A-Z_] | DIGIT )*
EXPONENT ::= [eE] [+#x2D]? DIGIT+
STRING_LITERAL1
         ::= "'" ( [^'\#xA#xD] | ECHAR | UCHAR )* "'"
STRING_LITERAL2
         ::= '"' ( [^"\#xA#xD] | ECHAR | UCHAR )* '"'
STRING_LITERAL_LONG1
         ::= "'''" ( ( "'" | "''" )? ( [^'\] | ECHAR | UCHAR ) )* "'''"
STRING_LITERAL_LONG2
         ::= '"""' ( ( '"' | '""' )? ( [^"\] | ECHAR | UCHAR ) )* '"""'
AT       ::= '@'
DIGIT    ::= [0-9]
UCHAR    ::= '\' ( 'u' | 'U' HEX HEX HEX HEX ) HEX HEX HEX HEX
ECHAR    ::= '\' [tbnrf\"']
PN_CHARS_BASE
         ::= [A-Za-z#xC0-#xD6#xD8-#xF6#xF8-#x2FF#x370-#x37D#x37F-#x1FFF#x200C-#x200D#x2070-#x218F#x2C00-#x2FEF#x3001-#xD7FF#xF900-#xFDCF#xFDF0-#xFFFD]
PN_CHARS_U
         ::= PN_CHARS_BASE
           | '_'
PN_CHARS ::= PN_CHARS_U
           | [-#xB7#x300-#x36F#x203F-#x2040]
           | DIGIT
PN_PREFIX
         ::= PN_CHARS_BASE ( ( PN_CHARS | '.' )* PN_CHARS )?
PN_LOCAL ::= ( PN_CHARS_U | ':' | DIGIT | PLX ) ( ( PN_CHARS | [.:] | PLX )* ( PN_CHARS | ':' | PLX ) )?
PLX      ::= PERCENT
           | PN_LOCAL_ESC
PERCENT  ::= '%' HEX HEX
HEX      ::= DIGIT
           | [A-Fa-f]
PN_LOCAL_ESC
         ::= '\' [_~.!$&'()*+,;=/?@%#x2D#x23]